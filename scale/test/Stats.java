package scale.test;

import java.io.*;
import java.util.Iterator;
import java.util.Enumeration;
import java.util.StringTokenizer;
import java.util.GregorianCalendar;
import java.text.SimpleDateFormat;
import java.text.DecimalFormat;

import scale.common.*;

/**
 * This class extracts the statistics from the output generated by a
 * compilation and/or execution.
 * <p>
 * $Id: Stats.java,v 1.37 2007-10-04 19:58:39 burrill Exp $
 * <p>
 * Copyright 2008 by the
 * <a href="http://ali-www.cs.umass.edu/">Scale Compiler Group</a>,<br>
 * <a href="http://www.cs.umass.edu/">Department of Computer Science</a><br>
 * <a href="http://www.umass.edu/">University of Massachusetts</a>,<br>
 * Amherst MA. 01003, USA<br>
 * All Rights Reserved.<br>
 * <p>
 */

public class Stats 
{
  protected static final int TXT = 0; // Text mode
  protected static final int CSV = 1; // CSV mode
  protected static final int TEX = 2; // LaTex mode
  protected static final int HTM = 3; // HTML mode

  private static final String helpMode  = "txt, csv, tex, or htm";
  private static final String helpRc    = "filename of configuration file";
  private static final String helpTitle = "Title for Tex or HTML table";
  private static final String helpFiles = "process the file(s) specified";
  private static final String helpBlks  = "process the benchmark(s) specified";
  private static final String helpTran  = "transpose output";
  private static final String helpSort  = "sort output rows";
  private static final String helpJoin  = "join stats files by benchmark";

  protected CmdParam   mode  = new CmdParam("m",      true,  CmdParam.STRING, "txt", helpMode);
  protected CmdParam   rc    = new CmdParam("f",      true,  CmdParam.STRING, null,  helpRc);
  protected CmdParam   title = new CmdParam("title",  true,  CmdParam.STRING, "Table", helpTitle);
  protected CmdParam   files = new CmdParam("i",      false, CmdParam.LIST,   null,  helpFiles);
  protected CmdParam   bks   = new CmdParam("b",      true,  CmdParam.LIST,   null,  helpBlks);
  protected CmdParam   tran  = new CmdParam("t",      true,  CmdParam.SWITCH, null,  helpTran);
  protected CmdParam   sort  = new CmdParam("sort",   true,  CmdParam.SWITCH, null,  helpSort);
  protected CmdParam   join  = new CmdParam("join",   true,  CmdParam.SWITCH, null,  helpJoin);

  protected CmdParam[] params = {rc, mode, bks, tran, join, sort, title};

  protected Vector<String> inputFiles     = null;               // A vector of files (Strings) to be processed.
  protected String[]       wantedVect     = null;               // null or original order of wanted statistics.
  protected String[]       ignoreVect     = null;               // null or vector of statistics to be ignored.
  protected Vector<String> fname          = new Vector<String>(10); // Names of the different "files".
  protected String[]       fnameA         = null;               // The elements of fname.
  protected Vector[]       byFileA        = null;               // The elements of byFile.

  protected Vector<Vector<Vector<String>>> byFile  = new Vector<Vector<Vector<String>>>(10); // The collected statistics by "file".

  protected HashSet<String>           collectedSet   = new HashSet<String>(29);    // Set of statistics collected.
  protected HashMap<String, Integer>  statMap        = new HashMap<String, Integer>(203);   // Map from statistic name to column index.
  protected String[]                  stats          = null;               // Names of the statistics.
  protected int[]                     statsI         = null;               // Index into the statistic vector of the statistic.
  protected int                       statIndex      = 0;

  protected HashMap<String, Integer>  benchmarkMap   = new HashMap<String, Integer>(203);  // Map from benchmark name to benchmark index.
  protected Vector<String>            benchmarkNames = new Vector<String>(15);    // Names of the different benchmarks.
  protected String[]                  benchmarks       = null;              // Names of the different benchmarks.
  protected int[]                     benchmarkI       = null;              // Index into vector of statistics for the benchmark.
  protected HashSet<String>           wantedBenchmarks = null;              // Set of benchmarks to be processed
  protected int                       benchmarkIndex   = 0;

  protected boolean doTranspose      = false;              // True if generated result should be transposed.
  protected boolean doJoin           = false;              // True if generated result should be joined by benchmark name.
  protected boolean doAll            = true;               // True if all statistics should be gathered.
  protected boolean doSort           = false;              // True if statistics should be sorted.
  protected int     displayMode      = TXT;
  protected HashMap<String, String> cvt = new HashMap<String, String>(23);    // Map from long statistic name to short name.

  protected String[] summaryVect    = null;                // null or vector of statistics to be summarized
  protected int[][]  svs            = null;                // Statistic indexes for .min, .max, and .avg

  protected String[] totalVect      = null;                // null or vector of statistics to be totaled
  protected int[]    tvs            = null;                // Statistic indexes for .sum

  protected Vector<Calc>   calcVect       = null;                // null or vector of statistics to be calculated
  protected int[]    ovs            = null;                // Statistic indexes for calculation targets
  protected String[] lax            = null;                // Calculation left arguments.
  protected String[] rax            = null;                // Calculation right arguments.
  protected char[]   opx            = null;                // Calculation operation.

  protected static final String[] nstats  = {
    "PRE",  "SCC", "CP", "LICM",
    "ValN", "UC",  "DV"};
  protected static final char[]   nstatsc = {
    'e', 'c', 'p', 'm'   ,
    'n', 'u', 'd'};
  protected static final String[] monthN  = {
    "Jan", "Feb", "Mar", "Apr",
    "May", "Jun", "Jul", "Aug",
    "Sep", "Oct", "Nov", "Dec"};
  protected static final String[] monthNI = {
    "01", "02", "03", "04",
    "05", "06", "07", "08",
    "09", "10", "11", "12"};
  protected static final String[] dstats  = {
    "day",  "month", "year",   "tz",
    "time", "dayw",  "monthn", "sdate"};

  protected int[] nstatsI = null;
  protected int[] dstatsI = null;
  protected int   aai     = 0;
  protected int   cati    = 0;
  protected int   gsi     = 0;

  /**
   * Process a set of files generated by a compilation.
   * @param args the command line arguments
   */
  public static void main(String[] args) 
  {
    Stats me = new Stats();

    Msg.setup(null);
    me.parseCmdLine(args, me.params);    // Parse the command line arguments
    me.process();
  }

  private boolean doBenchmark(String benchmark)
  {
    if (wantedBenchmarks == null)
      return true;

    return wantedBenchmarks.contains(benchmark);
  }

  private int getBenchmarkIndex(String key)
  {
    Integer index = benchmarkMap.get(key);
    if (index == null) {
      benchmarkNames.addElement(key);
      index = new Integer(benchmarkIndex++);
      benchmarkMap.put(key, index);
    }
    return index.intValue();
  }

  private Vector<String> getBenchmarkStatsVector(Vector<Vector<String>> bsv, int bdx)
  {
    int n = bsv.size();

    if (bdx < n) {
      Vector<String> v = bsv.elementAt(bdx);
      if (v == null) {
        v = new Vector<String>(statIndex);
        bsv.setElementAt(v, bdx);
      }
      return v;
    }

    for (int i = n; i < bdx; i++)
      bsv.addElement(null);

    Vector<String> vv = new Vector<String>(statIndex);
    bsv.addElement(vv);
    return vv;
  }

  private int getStatIndex(String key)
  {
    Integer index = statMap.get(key);
    if (index == null) {
      index = new Integer(statIndex++);
      statMap.put(key, index);
    }
    return index.intValue();
  }

  private String getStatsName(int idx)
  {
    int k = 0;
    for (int i = 0; i < statsI.length; i++) {
      if (statsI[i] == idx) {
        k = i;
        break;
      }
    }
    if (k < statsI.length)
      return stats[k];
    return "??";
  }

  private void addStatistic(Vector<String> byStat, int idx, String value)
  {
    int n = byStat.size();
    if (value.length() > 50) {
      System.out.println("** " + idx + " " + getStatsName(idx) + " " + value.length());
      Debug.printStackTrace();
    }
    if (idx < n) {
      byStat.setElementAt(value, idx);
      return;
    }

    for (int i = n; i < idx; i++)
      byStat.addElement(null);

    byStat.addElement(value);
  }

  private String getStatistic(Vector<String> byStat, int idx)
  {
    if (idx >= byStat.size())
      return null;
    return byStat.elementAt(idx);
  }

  private void remap()
  {
    int n = fname.size();

    byFileA = new Vector[n];
    fnameA  = new String[n];

    for (int fi = 0; fi < n; fi++) {
      byFileA[fi] = (Vector) byFile.elementAt(fi);
      fnameA[fi] = fname.elementAt(fi);
    }

    byFile = null;
    fname = null;
  }

  private void genBenchmarkMap()
  {
    int k = 0;

    benchmarks = new String[benchmarkIndex];
    benchmarkI = new int[benchmarkIndex];

    for (int i = 0; i < benchmarkIndex; i++) {
      String      benchmark = benchmarkNames.elementAt(i);
      int         bdx       = getBenchmarkIndex(benchmark);

      benchmarks[k] = benchmark;
      benchmarkI[k] = bdx;
      k++;
    }
    benchmarkNames = null;
    benchmarkMap = null;

    k = 0;

    stats  = new String[statIndex];
    statsI = new int[statIndex];

    Enumeration<String> es = statMap.keys();
    while (es.hasMoreElements()) {
      String      stat = es.nextElement();
      int         bdx  = getStatIndex(stat);

      stats[k]  = stat;
      statsI[k] = bdx;
      k++;
    }
  }

  /**
   * Do the processing.
   * Information is placed in a 3-dimensional array indexed by (file, benchmark, statistic).
   */
  @SuppressWarnings("unchecked")
  protected void process()
  {
    boolean doBs = false;
    boolean doFs = false;

    if (doAll || isIn("benchmark", wantedVect)) {
      getStatIndex("benchmark");
      collectedSet.add("benchmark");
      doBs  = true;
    }
    if (doAll || isIn("file", wantedVect)) {
      getStatIndex("file");
      collectedSet.add("file");
      doFs  = true;
    }

    aai  = newStat("Alias.Analysis");
    cati = newStat("AACategories");
    gsi  = newStat("Global.SSA");

    nstatsI = new int[nstats.length];
    for (int i = 0; i < nstats.length; i++)
      nstatsI[i] = newStat(nstats[i]);

    dstatsI = new int[dstats.length];
    for (int i = 0; i < dstats.length; i++)
      dstatsI[i] = newStat(dstats[i]);

    int nf = inputFiles.size();
    for (int i = 0; i < nf; i++) // Read each file.
      processDataFile(inputFiles.elementAt(i));

    if (summaryVect != null)
      setupSummaries();

    if (totalVect != null)
      setupTotals();

    if (calcVect != null)
      setupOthers();

    remap();
    genBenchmarkMap();

    // Add in benchmark and file values now so that the following logic is easier.

    if (doBs) {
      int index = getStatIndex("benchmark");
      for (int fi = 0; fi < byFileA.length; fi++) {
        Vector<Vector<String>> byBenchmark = byFileA[fi];
        int                    bbn         = byBenchmark.size();
        for (int bi = 0; bi < bbn; bi++) {
          Vector<String> byStat = getBenchmarkStatsVector(byBenchmark, bi);
          String         stat = benchmarks[bi];
          int            pos = stat.indexOf('/');
          if (pos >= 0)
            stat = stat.substring(pos + 1);
          addStatistic(byStat, index, stat);
        }
      }
    }
    if (doFs) {
      int index = getStatIndex("file");
      for (int fi = 0; fi < byFileA.length; fi++) {
        Vector<Vector<String>> byBenchmark = byFileA[fi];
        String stat                        = addQuotes(fnameA[fi]);
        int    bbn                         = byBenchmark.size();
        for (int bi = 0; bi < bbn; bi++) {
          Vector<String> byStat = getBenchmarkStatsVector(byBenchmark, bi);
          addStatistic(byStat, index, stat);
        }
      }
    }

    if (summaryVect != null)
      calcSummaries();

    if (totalVect != null)
      calcTotals();

    if (calcVect != null)
      calcOthers();

    // Put the statistics in sorted order.

    Vector<String>   sorted = new Vector<String>(collectedSet.size());
    Iterator<String> esn    = collectedSet.iterator();
    while (esn.hasNext()) { // Put the statistic names in order.
      String  stat   = esn.next();
      boolean doit   = true;

      if (!doAll) // See if it was specifically requested.
        doit = isIn(stat, wantedVect);

      if (doit)
        addStat(sorted, stat);
    }

    // Figure out how many rows of heading.

    int      num      = sorted.size();
    Vector[] head     = new Vector[num];
    int[]    idxMap   = new int[num];
    int      maxDepth = 0;

    for (int i = 0; i < num; i++) {
      String          stat     = sorted.elementAt(i);
      StringTokenizer tok      = new StringTokenizer(stat, ".", false);
      Vector<String>  headings = new Vector<String>(5);

      idxMap[i] = getStatIndex(stat);

      while (tok.hasMoreTokens()) {
        String s = tok.nextToken();
        String t = cvt.get(s);

        if (t != null)
          s = t;

        if ((s.length() > 0) && (displayMode == CSV))
          s = addQuotes(s);
        headings.addElement(s);
      }

      int d = headings.size();
      if (d > maxDepth)
        maxDepth = d;

      head[i] = headings;
    }

    for (int i = 0; i < num; i++) {
      Vector<String> headings = head[i];
      int    k        = headings.size();
      for (int j = 0; j < maxDepth - k; j++)
        headings.insertElementAt("", 0);
    }

    int rows = byFileA.length * benchmarkIndex + maxDepth;
    int cols = num;
    int numHeadings = 0;

    if (doTranspose) {
      rows = num * benchmarkIndex;
      cols = byFileA.length + maxDepth;
    } else if (doJoin) {
      rows = benchmarkIndex + maxDepth;
      cols = (num - 1) * byFileA.length + 1;
    }


    if ((rows == 0) || (cols == 0))
      return;

    String[][] array = new String[rows][cols];

    if (doTranspose) {
      numHeadings = -1;

      for (int j = 0; j < rows; j++) {
        Vector<String> headings = head[j % num];
        for (int i = 0; i < maxDepth; i++) {
          array[j][i] = headings.elementAt(i);
        }
      }

      for (int i = 0; i < byFileA.length; i++) {
        String fileName    = fnameA[i];
        Vector<Vector<String>> byBenchmark = byFileA[i];
        int    bbn         = byBenchmark.size();
        for (int j = 0; j < benchmarkIndex; j++) {
          String benchmark = benchmarks[j];
          if (bbn > j) {
            Vector<String> byStat = byBenchmark.elementAt(j);
            int            col    = i + maxDepth;
            for (int k = 0; k < num; k++) {
              int row = j * num + k;
              array[row][col] = getStatistic(byStat, idxMap[k]);
            }
          }
        }
      }
    } else if (doJoin) {
      numHeadings = maxDepth;

      Vector<String> headings = head[0];
      for (int i = 0; i < maxDepth; i++)
        array[i][0] = headings.elementAt(i);

      int jj = 1;
      for (int c = 1; c < cols; c++) {
        if (jj >= num)
          jj = 1;
        headings = head[jj];
        for (int i = 0; i < maxDepth; i++)
          array[i][c] = headings.elementAt(i);
        jj++;
      }

      String                 fileName    = fnameA[0];
      Vector<Vector<String>> byBenchmark = byFileA[0];
      int    bbn         = byBenchmark.size();
      for (int j = 0; j < bbn; j++) {
        String benchmark = benchmarks[j];
        if (bbn > j) {
          Vector<String> byStat = byBenchmark.elementAt(j);
          int    row    = j + maxDepth;
          array[row][0] = getStatistic(byStat, idxMap[0]);
        }
      }

      for (int i = 0; i < byFileA.length; i++) {
        fileName    = fnameA[i];
        byBenchmark = byFileA[i];
        bbn         = byBenchmark.size();
        for (int j = 0; j < benchmarkIndex; j++) {
          String benchmark = benchmarks[j];
          if (bbn > j) {
            Vector<String> byStat = byBenchmark.elementAt(j);
            int    row    = j + maxDepth;
            for (int k = 1; k < num; k++)
              array[row][k + i * (num - 1)] = getStatistic(byStat, idxMap[k]);
          }
        }
      }
    } else {
      numHeadings = maxDepth;

      for (int j = 0; j < num; j++) {
        Vector<String> headings = head[j];
        for (int i = 0; i < maxDepth; i++) {
          array[i][j] = headings.elementAt(i);
        }
      }

      for (int i = 0; i < byFileA.length; i++) {
        String                 fileName    = fnameA[i];
        Vector<Vector<String>> byBenchmark = byFileA[i];
        int    bbn         = byBenchmark.size();
        for (int j = 0; j < benchmarkIndex; j++) {
          String benchmark = benchmarks[j];
          if (bbn > j) {
            Vector<String> byStat = byBenchmark.elementAt(j);
            int    row    = (i * benchmarkIndex) + j + maxDepth;
            for (int k = 0; k < num; k++)
              array[row][k] = getStatistic(byStat, idxMap[k]);
          }
        }
      }
    }

    // Figure out the width of each column.

    int[] width = new int[cols];
    for (int j = 0; j < cols; j++) {
      for (int i = 0; i < rows; i++) {
        String s = array[i][j];
        if (s == null) {
          s = "";
          array[i][j] = s;
        }
        int w = s.length();
        if (w > width[j])
          width[j] = w;
      }
    }

    if (doSort)
      sortArray(array, numHeadings);

    // Output the statistics.

    switch (displayMode) {
    default:
    case TXT: displayTXT(array, width, numHeadings); break;
    case CSV: displayCSV(array, width);              break;
    case TEX: displayTEX(array, width, numHeadings); break;
    case HTM: displayHTM(array, width, numHeadings); break;
    }
  }

  private int newStat(String stat)
  {
    collectedSet.add(stat);
    return getStatIndex(stat);
  }

  private abstract class SParse
  {
    private int    index;
    private int    findex;
    private int    eindex;
    private char[] line;

    public SParse()
    {
    }

    public void newLine(String str, int start)
    {
      line  = str.toCharArray();
      index = start;
    }

    public abstract void parse(String str);

    public String extractField()
    {
      skipWhitespace();
      findFieldEnd();
      return new String(line, findex, eindex - findex);
    }

    private void skipWhitespace()
    {
      while ((index < line.length) && Character.isWhitespace(line[index]))
        index++;
    }

    private void findFieldEnd()
    {
      findex = index;

      if (line[index] == '"') {
        index++;
        findex++;
        while (index < line.length) {
          char c = line[index];
          if (c == '"')
            break;
          index++;
        }
        eindex = index++;
        if (line[index] == ',')
          index++;
      } else {
        while (index < line.length) {
          char c = line[index];
          if (Character.isWhitespace(c))
            break;
          if (c == ',')
            break;
          if (c == ')')
            break;
          index++;
        }
      }
      eindex = index++;
      skipWhitespace();
      if ((index < line.length) && (line[index] == ','))
        index++;
    }
  }

  private final class Statistic extends SParse
  {
    public String benchmark;
    public String value;
    public String stat;
    public String className;

    public void parse(String str)
    {
      newLine(str, 7);

      benchmark = extractField();
      value     = extractField();
      stat      = extractField();
      className = extractField();
    }
  }
 
  private class DateStat extends SParse
  {
    private String dayw;
    private String month;
    private String day;
    private String year;
    private String time;
    private String tz;

    public void parse(String str)
    {
      newLine(str, 0);
      dayw  = extractField();
      month = extractField();
      day   = extractField();
      time  = extractField();
      tz    = extractField();
      year  = extractField();
    }

    public String getStat(int k)
    {
      switch (k) {
      case 0: return day;
      case 1: return month;
      case 2: return year;
      case 3: return tz;
      case 4: return time;
      case 5: return dayw;
      case 6: return monthnum(month);
      case 7: return "\"" + monthnum(month) + "/" + day + "/" + year.substring(2) + "\"";
      }
      return "??";
    }

    private String monthnum(String month)
    {
      for (int i = 0; i < 12; i++)
        if (monthN[i].equals(month))
          return monthNI[i];
      return "??";
    }
  }

  private void processDataFile(String file)
  {
    Vector<Vector<String>> byBenchmark = new Vector<Vector<String>>(15);
    Statistic statistic   = new Statistic();
    DateStat  date        = new DateStat();
    int       rIndex      = 0;

    fname.addElement(file + File.separator + rIndex);
    byFile.addElement(byBenchmark);

    try {
      FileReader     fis = new FileReader(file);
      BufferedReader br  = new BufferedReader(fis);

      while (true) { // Read each line of each file.
        String line = br.readLine();

        if (line == null)
          break;

        line = line.trim();

        if (line.startsWith("(stat,")) { // Collect the statistics.
          statistic.parse(line);

          if (doBenchmark(statistic.benchmark)) {
            String  key  = statistic.className + "." + statistic.stat;

            if ((ignoreVect == null) || !isIn(key, ignoreVect)) {
              int            bdx    = getBenchmarkIndex(statistic.benchmark);
              Vector<String> byStat = getBenchmarkStatsVector(byBenchmark, bdx);

              if (key.equals("scale.test.Scale.opts")) {
                String aal = "";
                String cat = "" + statistic.value.charAt(3);
                boolean flg = true;
                switch (statistic.value.charAt(1)) {
                case '0': aal = ""; flg = false; break;
                case '1': aal = "Simple";    break;
                case '2': aal = "Steens";    break;
                case '3': aal = "Shapiro";   break;
                case '4': aal = "Simple-I";  break;
                case '5': aal = "Steens-I";  break;
                case '6': aal = "Shapiro-I"; break;
                }
                addStatistic(byStat, aai, aal);
                addStatistic(byStat, cati, cat);
                char ssa = statistic.value.charAt(4);
                addStatistic(byStat, gsi, (ssa == 'S') ? "Y" : " ");
                statistic.value = statistic.value.substring((ssa == 'S' || ssa == 's') ? 5 : 4);
                if (flg)
                  for (int k = 0; k < nstats.length; k++)
                    addStatistic(byStat, nstatsI[k],
                                 (0 <= statistic.value.indexOf(nstatsc[k])) ? "Y" : " ");
              } else if (key.equals("scale.date")) {
                date.parse(statistic.value);
                for (int k = 0; k < dstats.length; k++)
                  addStatistic(byStat, dstatsI[k], date.getStat(k));
              }

              int idx = getStatIndex(key);
              collectedSet.add(key);
              addStatistic(byStat, idx, statistic.value);
            }
          }
        } else if (line.startsWith("**** EOF ****")) {
          rIndex++;
          byBenchmark = new Vector<Vector<String>>(15);
          fname.addElement(file + File.separator + rIndex);
          byFile.addElement(byBenchmark);
        }
      }
      fis.close();
      br.close();
    } catch(IOException ex) {
      ex.printStackTrace();
    }
  }

  private boolean[][] crossProduct(String[] stats, String[] pat)
  {
    int         m  = stats.length;
    int         n  = pat.length;
    boolean[][] cp = new boolean[m][n];

    for (int i = 0; i < m; i++)
      for (int j = 0; j < n; j++)
        cp[i][j] = matches(stats[i], pat[j]);

    return cp;
  }

  private void setupSummaries()
  {
    int n = summaryVect.length;

    svs = new int[3][n];

    for (int j = 0; j < n; j++) {
      String stat = summaryVect[j];
      String min  = stat + ".min";
      String max  = stat + ".max";
      String avg  = stat + ".avg";

      collectedSet.add(min);
      collectedSet.add(max);
      collectedSet.add(avg);

      svs[0][j] = getStatIndex(min);
      svs[1][j] = getStatIndex(max);
      svs[2][j] = getStatIndex(avg);
    }
  }

  private void calcSummaries()
  {
    DecimalFormat format = new DecimalFormat("####0.00");
    int           n      = summaryVect.length;
    boolean[][]   match  = crossProduct(stats, summaryVect);

    for (int fi = 0; fi < byFileA.length; fi++) {
      @SuppressWarnings("unchecked")
      Vector<Vector<String>> byBenchmark = byFileA[fi];

      for (int bi = 0; bi < benchmarkI.length; bi++) {
        int    bdx    = benchmarkI[bi];
        if (bdx >= byBenchmark.size())
          continue;

        Vector<String> byStat = byBenchmark.elementAt(bdx);

        if (byStat == null)
          continue;

        for (int i = 0; i < n; i++) {
          double min   =  Double.MAX_VALUE;
          double max   = -Double.MAX_VALUE;
          double sum   = 0;
          int    count = 0;

          for (int j = 0; j < stats.length; j++) {
            if (match[j][i]) {
              int    idx = statsI[j];
              String val = getStatistic(byStat, idx);
              if (val != null) {
                double value = Double.valueOf(val).doubleValue();
                sum += value;
                count++;
                if (value > max)
                  max = value;
                if (value < min)
                  min = value;
              }
            }
          }
          String smin = "";
          String smax = "";
          String savg = "";
          try {
            if (min == Double.MAX_VALUE)
              smin = "NA";
            else
              smin = format.format(min);
            if (max == -Double.MAX_VALUE)
              smax = "NA";
            else
              smax = format.format(max);
            if (count > 0)
              savg = format.format(sum / (double) count);
          } catch(java.lang.NumberFormatException ex) {
          }

          int imin  = svs[0][i];
          int imax  = svs[1][i];
          int iavg  = svs[2][i];
          addStatistic(byStat, imin, smin);
          addStatistic(byStat, imax, smax);
          addStatistic(byStat, iavg, savg);
        }
      }
    }
  }

  private void setupTotals()
  {
    int n     = totalVect.length;

    tvs = new int[n];

    for (int j = 0; j < totalVect.length; j++) {
      String sum = totalVect[j] + ".sum";
      collectedSet.add(sum);
      tvs[j] = getStatIndex(sum);
    }
  }

  private void calcTotals()
  {
    int         n     = totalVect.length;
    boolean[][] match = crossProduct(stats, totalVect);

    for (int fi = 0; fi < byFileA.length; fi++) {
      @SuppressWarnings("unchecked")
      Vector<Vector<String>> byBenchmark = byFileA[fi];

      for (int bi = 0; bi < benchmarkI.length; bi++) {
        int    bdx    = benchmarkI[bi];
        Vector<String> byStat = byBenchmark.elementAt(bdx);

        if (byStat == null)
          continue;

        for (int i = 0; i < n; i++) {
          double sum  = 0;

          for (int j = 0; j < stats.length; j++) {
            if (match[j][i]) {
              int    idx = statsI[j];
              String val = getStatistic(byStat, idx);
              if (val != null) {
                double value = Double.valueOf(val).doubleValue();
                sum += value;
              }
            }
          }
          String ssum = Double.toString(sum);
          addStatistic(byStat, tvs[i], ssum);
        }
      }
    }
  }

  private void setupOthers()
  {
    int n = calcVect.size();

    lax = new String[n];
    rax = new String[n];
    opx = new char[n];

    ovs = new int[n];

    for (int j = 0; j < n; j++) {
      Calc c = calcVect.elementAt(j);
      collectedSet.add(c.target);
      ovs[j] = getStatIndex(c.target);
      lax[j] = c.la;
      rax[j] = c.ra;
      opx[j] = c.op;
    }
  }

  private void calcOthers()
  {
    int         n      = lax.length;
    boolean[][] match1 = crossProduct(stats, lax);
    boolean[][] match2 = crossProduct(stats, rax);

    for (int fi = 0; fi < byFileA.length; fi++) {
      @SuppressWarnings("unchecked")
      Vector<Vector<String>> byBenchmark = byFileA[fi];

      for (int bi = 0; bi < benchmarkI.length; bi++) {
        int    bdx    = benchmarkI[bi];

        if (bdx >= byBenchmark.size())
          continue;

        Vector<String> byStat = byBenchmark.elementAt(bdx);

        if (byStat == null)
          continue;

        for (int i = 0; i < n; i++) {
          float sum = 0;
          char  op  = opx[i];
          boolean flg = true;
          for (int j = 0; j < stats.length; j++) {
            if (match1[j][i]) {
              int    idx = statsI[j];
              String val = getStatistic(byStat, idx);
              flg = false;
              if (val != null) {
                try {
                  float value = Float.valueOf(val).floatValue();
                  sum += value;
                } catch (java.lang.Exception ex) {
                }
              }
            }
          }
          if (flg) {
            try {
              float value = Float.valueOf(lax[i]).floatValue();
              sum += value;
            } catch (java.lang.Exception ex) {
              System.out.println("** Exception1 " + lax[i]);
            }
          }
          flg = true;
          for (int j = 0; j < stats.length; j++) {
            if (match2[j][i]) {
              int    idx = statsI[j];
              String val = getStatistic(byStat, idx);
              flg = false;
              if (val != null) {
                try {
                  float value = Float.valueOf(val).floatValue();
                  if (op == '+')
                    sum += value;
                  else if (op == '-')
                    sum -= value;
                  else if (op == '*')
                    sum *= value;
                  else if (op == '/') {
                    if (sum == value)
                      sum = 1.0F;
                    else
                      sum /= value;
                    sum = ((int) (sum * 100)) / 100.0F;
                  }
                } catch (java.lang.Exception ex) {
                }
              }
            }
          }
          if (flg) {
            try {
              float value = Float.valueOf(rax[i]).floatValue();
              if (op == '+')
                sum += value;
              else if (op == '-')
                sum -= value;
              else if (op == '*')
                sum *= value;
              else if (op == '/') {
                if (sum == value)
                  sum = 1.0F;
                else
                  sum /= value;
                sum = ((int) (sum * 100)) / 100.0F;
              }
            } catch (java.lang.Exception ex) {
              System.out.println("** Exception2 " + rax[i]);
            }
          }

          String ssum = "";
          long x = (long) sum;
          if (((float) x) != sum)
            ssum = Float.toString(sum);
          else {
            ssum = Long.toString(x);
            if ("0".equals(ssum))
              ssum = "";
          }
          addStatistic(byStat, ovs[i], ssum);
        }
      }
    }
  }

  private String addQuotes(String s)
  {
    StringBuffer buf = new StringBuffer("\"");
    buf.append(s);
    buf.append('"');
    return buf.toString();
  }

  private boolean isIn(String stat, String[] v)
  {
    int n = v.length;

    for (int i = 0; i < n; i++) {
      String sum = v[i];
      if (matches(stat, sum))
        return true;
    }

    return false;
  }

  private void displayCSV(String[][] array, int[] width)
  {
    int rows = array.length;
    int cols = array[0].length;

    for (int row = 0; row < rows; row++) {
      StringBuffer line = new StringBuffer();
      for (int col = 0; col < cols; col++) {
        if (col > 0)
          line.append(',');
        line.append(array[row][col]);
      }
      System.out.println(line.toString());
    }
  }

  private void displayTXT(String[][] array, int[] width, int numHeadings)
  {
    int     lineLength = 40;
    int     rows = array.length;
    int     cols = array[0].length;
    boolean[] rightAlign = determineAlignment(array[array.length - 1]);

    for (int row = 0; row < rows; row++) {
      if (row == numHeadings) {
        for (int i = 0; i < lineLength; i++) System.out.print("-");
        System.out.println();
      }

      StringBuffer line = new StringBuffer();
      for (int col = 0; col < cols; col++) {
        if (col > 0)
          line.append(' ');
        String val = array[row][col];
        int    w   = width[col] - val.length();
        if (rightAlign[col])
          while (w-- > 0) line.append(' ');
        line.append(val);
        if (!rightAlign[col])
          while (w-- > 0) line.append(' ');
      }
      lineLength = line.length();
      System.out.println(line.toString());
    }
  }

  private void displayTEXHeading(String[] lines, boolean[] rightAlign)
  {
    int numHeadings = lines.length;
    int cols = rightAlign.length;
    System.out.print("\\begin{tabular}{");
    for (int i = 0; i < cols; i++) System.out.print(rightAlign[i] ? "r" : "l");
    System.out.println("}");
    for (int i = 0; i < numHeadings; i++)
      System.out.println(lines[i]);
    System.out.println("\\hline");
  }

  private String displayTEXRow(String[][] array, int[] width, int row, boolean[] rightAlign)
  {
    int cols = array[0].length;
    StringBuffer line = new StringBuffer();
    for (int col = 0; col < cols; col++) {
      if (col > 0)
        line.append(" & ");
      String val = array[row][col];
      int    w   = width[col] - val.length();
      if (rightAlign[col])
        while (w-- > 0) line.append(' ');
      line.append(val);
      if (!rightAlign[col])
        while (w-- > 0) line.append(' ');
    }
    line.append(" \\\\");
    return line.toString();
  }

  private void displayTEX(String[][] array, int[] width, int numHeadings)
  {
    int rows = array.length;
    int cols = array[0].length;
    boolean[] rightAlign = determineAlignment(array[array.length - 1]);
    String[] lines = new String[numHeadings];

    for (int row = 0; row < numHeadings; row++) {
      String str = displayTEXRow(array, width, row, rightAlign);
      lines[row] = str;
    }

    String last = array[numHeadings][0];
    displayTEXHeading(lines, rightAlign);

    for (int row = numHeadings; row < rows; row++) {

      if (!last.equals(array[row][0])) {
        System.out.println("\\end{tabular}\n\\vskip 0.5 in");
        displayTEXHeading(lines, rightAlign);
      }

      last = array[row][0];

      String str = displayTEXRow(array, width, row, rightAlign);
      System.out.println(str);
    }
    System.out.println("\\caption{" + title.getStringValue() + "}");
    System.out.println("\\end{tabular}\n\\vskip 0.5 in");
  }

  private String displayTHRow(String[][] array, int[] width, int row)
  {
    int          cols = array[0].length;
    StringBuffer line = new StringBuffer("<tr>");

    for (int col = 0; col < cols; col++) {
      line.append("<th style=\"color:firebrick\">");
      String val = array[row][col];
      if (val.equals(""))
        val = "&nbsp;";
      line.append(val);
      line.append("</th>");
    }
    return line.toString();
  }

  private String displayTDRow(String[][] array,
                              int[]      width,
                              int        row,
                              boolean[]  rightAlign,
                              String     color)
  {
    int          cols = array[0].length;
    StringBuffer line = new StringBuffer("<tr>");

    for (int col = 0; col < cols; col++) {
      line.append("<td");
      if (rightAlign[col])
        line.append(" align=\"right\"");
      line.append(" style=\"color:");
      line.append(color);
      line.append("\"");
      line.append(">");
      String val = array[row][col];
      if (val.equals(""))
        val = "&nbsp;";
      line.append(val);
      line.append("</td>");
    }
    return line.toString();
  }

  private void displayHTM(String[][] array, int[] width, int numHeadings)
  {
    int       rows       = array.length;
    int       cols       = array[0].length;
    boolean[] rightAlign = determineAlignment(array[array.length - 1]);
    String    t          = title.getStringValue();
    GregorianCalendar cal = new GregorianCalendar();
    SimpleDateFormat  df  = new SimpleDateFormat();
    df.setCalendar(cal);

    System.out.print("<html>\n<head>\n<title>");
    System.out.print(t);
    System.out.print(" ");
    System.out.print(df.format(cal.getTime()));
    System.out.print("</title>\n</head>\n<body>\n<h1>");
    System.out.print(t);
    System.out.print(" ");
    System.out.print(df.format(cal.getTime()));
    System.out.println("</h1>\n<table border=\"1\" cols=\"" + cols + "\">");
    System.out.print("<colgroup>");
    for (int col = 0; col < cols; col++) {
      if (rightAlign[col])
        System.out.print("<COL ALIGN=\"RIGHT\">");
      else
        System.out.print("<COL>");
    }
    System.out.println("</colgroup><thead>");

    for (int row = 0; row < numHeadings; row++)
      System.out.println(displayTHRow(array, width, row));

    System.out.println("</thead><tbody>");

    String color = "green";
    String colorn = "firebrick";
    String last = numHeadings < rows ? array[numHeadings][0] : "??";
    for (int row = numHeadings; row < rows; row++) {
      if (!last.equals(array[row][0])) {
        String tt = color;
        color = colorn;
        colorn = tt;
        last = array[row][0];
      }
      System.out.println(displayTDRow(array, width, row, rightAlign, color));
    }

    System.out.println("</tbody></table>");
    System.out.println("</body></html>");
  }

  private boolean[] determineAlignment(String[] row)
  {
    int cols = row.length;
    boolean[] rightAlign = new boolean[cols];
    for (int i = 0; i < cols; i++) {
      boolean b = false;
      if (row[i].length() > 0) {
        char f = row[i].charAt(0);
        b = (Character.getType(f) == Character.DECIMAL_DIGIT_NUMBER);
      } else
        b = true;
      rightAlign[i] = b;
    }
    return rightAlign;    
  }

  private void sortArray(String[][] array, int numHeadings)
  {
    int rows = array.length;
    int cols = array[0].length;
    boolean flag = true;

    if (numHeadings < 0)
      numHeadings = 0;

    while (flag) {
      flag = false;
      for (int row = numHeadings; row < rows - 1; row++) {
        int lex = 0;
        for (int col = 0; col < cols; col++) {
          lex = array[row][col].compareTo(array[row + 1][col]);
          if (lex != 0)
            break;
        }
        if (lex > 0) {
          flag = true;
          String[] t = array[row];
          array[row] = array[row + 1];
          array[row + 1] = t;
        }
      }
    }
  }

  private int gooble(String pattern, int ip)
  {
    int ip2 = pattern.indexOf('*', ip);
    if (ip2 < 0)
      ip2 = pattern.length();
    int ip3 = pattern.indexOf('?', ip);
    if ((ip3 >= 0) && (ip3 < ip2))
      ip2 = ip3;
    return ip2;
  }

  private boolean isSame(String s, String p)
  {
    if (s.endsWith(p)) {
      int lp = p.length();
      int ls = s.length();
      if ((lp == ls) || (s.charAt(ls - lp - 1) == '.'))
        return true;
    }
    return false;
  }

  /**
   * Match two strings. A ? matches a single character and an * matches multiple characters.
   * @return true if the strings match
   */
  private boolean matches(String s, String pattern)
  {
    if (isSame(s, pattern))
        return true;

    int x = pattern.indexOf('*');
    int y = pattern.indexOf('?');
    if ((x < 0) && (y < 0))
      return false;

    int sl = s.length();
    int pl = pattern.length();
    int is = 0;
    int ip = 0;

    while ((is < sl) && (ip < pl)) {
      int p = pattern.charAt(ip);
      if (p == '?') {
        is++;
        ip++;
      } else if (p == '*') {
        ip++;
        if (ip >= pl)
          return true;
        int ip2 = gooble(pattern, ip);
        is = s.indexOf(pattern.substring(ip, ip2), is);
        if (is < 0)
          return false;
        is += ip2 - ip;
        ip = ip2;
      } else {
        int ip2 = gooble(pattern, ip);
        if (!s.startsWith(pattern.substring(ip, ip2), is))
          return false;
        is += ip2 - ip;
        ip = ip2;
      }
    }

    return ((is >= sl) && (ip >= pl));
  }

  /**
   * Add a statistic name to the sorted vector.
   * The vector is sorted alphabetically or in the user specified order 
   * depending whether the user used the -s command line switch.
   * @param sorted is the vector that is ordered
   * @param stat is the statistic to add to sorted
   */
  private void addStat(Vector<String> sorted, String stat)
  {
    int l = sorted.size();
    if (wantedVect != null) { // Place in user specified order
      int ls = wantedVect.length;
      int k;
      for (k = 0; k < ls; k++)
        if (matches(stat, wantedVect[k]))
          break;
      for (int i = 0; i < l; i++) {
        String s = sorted.elementAt(i);
        int j;
        for (j = 0; j < ls; j++)
          if (isSame(s, wantedVect[j]))
            break;
        if (k < j) {
          sorted.insertElementAt(stat, i);
          return;
        }
      }
      sorted.addElement(stat);
    } else { // Place in alphabetical order
      for (int i = 0; i < l; i++) {
        String s = sorted.elementAt(i);
        int    n = s.compareTo(stat);
        if (n >= 0) {
          if (n > 0) {
            sorted.insertElementAt(stat, i);
          }
          return;
        }
      }
      sorted.addElement(stat);
    }
  }

  /**
   * Process the command line parameters.
   * @param args the array of command line parameters
   * @param params an array of allowed command line parameters
   */
  protected void parseCmdLine(String[] args, CmdParam[] params)
  {
    try {
      if (CmdParam.parse(this.getClass().getName(), args, params, files))
        System.exit(0);
    } catch(scale.common.InvalidKeyException ex) {
      System.out.println(ex.getMessage());
      CmdParam.usage(System.out, this.getClass().getName(), params);
      System.exit(1);
    }

    displayMode = TXT;
    String dm = mode.getStringValue();
    if (dm != null) {
      if (dm.equals("csv"))
        displayMode = CSV;
      else if (dm.equals("tex"))
        displayMode = TEX;
      else if (dm.equals("htm"))
        displayMode = HTM;
    }

    inputFiles = files.getStringValues();

    Vector<String> wanted  = new Vector<String>();
    Vector<String> ignore  = new Vector<String>();
    Vector<String> summary = new Vector<String>();
    Vector<String> total   = new Vector<String>();

    if (bks.specified()) {
      Vector<String> v  = bks.getStringValues();
      int            vn = v.size();

      wantedBenchmarks = new HashSet<String>(29);

      for (int i = 0; i < vn; i++)
        wantedBenchmarks.add(v.elementAt(i));
    }

    doTranspose = tran.specified();
    doJoin      = join.specified();
    doSort      = sort.specified();

    if (rc.specified())
      processConfigFile(rc.getStringValue(), wanted, ignore, total, summary);

    wantedVect  = convertToArray(wanted);
    totalVect   = convertToArray(total);
    ignoreVect  = convertToArray(ignore);
    summaryVect = convertToArray(summary);

    if (wantedVect != null) {
      for (int i = 0; i < wantedVect.length; i++) {
        String stat = wantedVect[i];
        if ((ignoreVect != null) && isIn(stat, ignoreVect)) {
          System.err.println("Intersection of wanted & ignored not null - " + stat);
          System.exit(1);
        }
      }
    }
  }

  private String[] convertToArray(Vector<String> v)
  {
    String[] s = null;
    int    n   = v.size();
    if (n > 0) {
      s = new String[n];
      for (int i = 0; i < n; i++)
        s[i] = v.elementAt(i);
    }
    return s;
  }

  private void processConfigFile(String         file,
                                 Vector<String> wanted,
                                 Vector<String> ignore,
                                 Vector<String> total,
                                 Vector<String> summary)
  {
    String  line  = "";
    boolean ok    = true;

    try {
      FileReader     fis   = new FileReader(file);
      BufferedReader br    = new BufferedReader(fis);
      Vector<String> stats = new Vector<String>(10);

      while (ok) { // Read each line of each file.
        line = br.readLine();
        if (line == null)
          return;

        line = line.trim();

//      System.err.println("L " + line);

        if ((line.length() == 0) || (line.charAt(0) == '#'))
          continue;

        StringTokenizer tok = new StringTokenizer(line, "\n\r\t ,", false);

        if (!tok.hasMoreTokens())
          continue;

        String cmd = tok.nextToken();

        stats.clear();
        while (tok.hasMoreTokens())
          stats.addElement(tok.nextToken());

        int n = stats.size();

        if (cmd.equals("show")) {
          doAll = false;
          if (wanted == null)
            wanted = new Vector<String>(10);
          int i;
          for (i = 0; i < n; i++) {
            String s = stats.elementAt(i);
            if (s.equals("all")) {
              doAll = true;
              wanted = null;
              if (1 != n)
                ok = false;
              break;
            }
            wanted.addElement(s);
          }
        } else if (cmd.equals("ignore")) {
          if (ignore == null)
            ignore = new Vector<String>(10);
          for (int i = 0; i < n; i++)
            ignore.add(stats.elementAt(i));
        } else if (cmd.equals("total")) {
          if (total == null)
            total = new Vector<String>(10);
          for (int i = 0; i < n; i++)
            total.add(stats.elementAt(i));
        } else if (cmd.equals("summary")) {
          if (summary == null)
            summary = new Vector<String>(10);
          for (int i = 0; i < n; i++)
            summary.add(stats.elementAt(i));
        } else if (cmd.equals("sort") && (n == 0)) {
          doSort = true;
        } else if (cmd.equals("alias")) {
          if (n == 2)
            cvt.put(stats.elementAt(0), stats.elementAt(1));
          else {
            ok = false;
            break;
          }
        } else if (cmd.equals("calc")) {
          Calc c = new Calc(line);
          if (c.valid) {
            if (calcVect == null)
              calcVect = new Vector<Calc>(5);
            calcVect.addElement(c);
          } else {
                ok = false;
            break;
          }
        } else {
                ok = false;
          break;
        }
      }
      fis.close();
      br.close();
    } catch(IOException ex) {
      ex.printStackTrace();
    }
    if (!ok) {
      System.err.println("Invalid configuration file - " + line);
      System.exit(1);
    }
  }

  private static class Calc
  {
    public String  target;
    public String  la;
    public String  ra;
    public char    op = ' ';
    public boolean valid = true;

    public Calc(String line)
    {
      StringTokenizer tok = new StringTokenizer(line, "\n\r\t -+=/*", true);

      tok.nextToken(); // Skip calc command

      target = next(tok);
      String t = next(tok);
      la = next(tok);
      String o = next(tok);
      ra = next(tok);

      if (o.equals("+"))
        op = '+';
      else if (o.equals("-"))
        op = '-';
      else if (o.equals("/"))
        op = '/';
      else if (o.equals("*"))
        op = '*';
      else {
        valid = false;
        return;
      }

      String x = next(tok);
      if ((!t.equals("=")) || (x != null))
        valid = false;
    }

    private String next(StringTokenizer tok)
    {
      while (tok.hasMoreTokens()) {
        String s = tok.nextToken();
        if (!s.equals(" "))
          return s;
      }
      return null;
    }

    public String toString()
    {
      return target + " = " + la + " " + op + " " + ra + " " + valid;
    }
  }
}

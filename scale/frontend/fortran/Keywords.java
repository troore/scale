package scale.frontend.fortran;

/**
 * This class defines the Fortran keywords.
 * <b>Do not edit.</b>
 * <p>
 * Copyright 2008 by the
 * <a href="http://ali-www.cs.umass.edu/">Scale Compiler Group</a>,<br>
 * <a href="http://www.cs.umass.edu/">Department of Computer Science</a><br>
 * Amherst MA. 01003, USA<br>
 * All Rights Reserved.<br>
 * <p>
 * This file is generated by the MK class.
 */

public final class Keywords
{
  public static final int NA                  = 0;
  public static final int ACCESS              = 1;
  public static final int ALLOCATABLE         = 2;
  public static final int ALLOCATE            = 3;
  public static final int ASSIGN              = 4;
  public static final int BACKSPACE           = 5;
  public static final int BLANK               = 6;
  public static final int BLOCK               = 7;
  public static final int BLOCKDATA           = 8;
  public static final int CALL                = 9;
  public static final int CASE                = 10;
  public static final int CHARACTER           = 11;
  public static final int CLOSE               = 12;
  public static final int COMMON              = 13;
  public static final int COMPLEX             = 14;
  public static final int CONTAINS            = 15;
  public static final int CONTINUE            = 16;
  public static final int CYCLE               = 17;
  public static final int DATA                = 18;
  public static final int DEALLOCATE          = 19;
  public static final int DIMENSION           = 20;
  public static final int DIRECT              = 21;
  public static final int DO                  = 22;
  public static final int DOUBLE              = 23;
  public static final int DOUBLEPRECISION     = 24;
  public static final int DOUBLECOMPLEX       = 25;
  public static final int ELEMENTAL           = 26;
  public static final int ELSE                = 27;
  public static final int ELSEIF              = 28;
  public static final int END                 = 29;
  public static final int ENDBLOCKDATA        = 30;
  public static final int ENDDO               = 31;
  public static final int ENDFILE             = 32;
  public static final int ENDFORALL           = 33;
  public static final int ENDFUNCTION         = 34;
  public static final int ENDIF               = 35;
  public static final int ENDINTERFACE        = 36;
  public static final int ENDMODULE           = 37;
  public static final int ENDPROGRAM          = 38;
  public static final int ENDSELECT           = 39;
  public static final int ENDSUBROUTINE       = 40;
  public static final int ENDTYPE             = 41;
  public static final int ENDWHERE            = 42;
  public static final int ENTRY               = 43;
  public static final int EQUIVALENCE         = 44;
  public static final int ERR                 = 45;
  public static final int EXIST               = 46;
  public static final int EXIT                = 47;
  public static final int EXTERNAL            = 48;
  public static final int FILE                = 49;
  public static final int FMT                 = 50;
  public static final int FORALL              = 51;
  public static final int FORM                = 52;
  public static final int FORMAT              = 53;
  public static final int FORMATTED           = 54;
  public static final int FUNCTION            = 55;
  public static final int GOTO                = 56;
  public static final int IF                  = 57;
  public static final int IMPLICIT            = 58;
  public static final int IN                  = 59;
  public static final int INCLUDE             = 60;
  public static final int INOUT               = 61;
  public static final int INQUIRE             = 62;
  public static final int INTEGER             = 63;
  public static final int INTENT              = 64;
  public static final int INTERFACE           = 65;
  public static final int INTRINSIC           = 66;
  public static final int IOSTAT              = 67;
  public static final int KIND                = 68;
  public static final int LEN                 = 69;
  public static final int LOGICAL             = 70;
  public static final int MODULE              = 71;
  public static final int NAME                = 72;
  public static final int NAMED               = 73;
  public static final int NAMELIST            = 74;
  public static final int NEXTREC             = 75;
  public static final int NONE                = 76;
  public static final int NULL                = 77;
  public static final int NULLIFY             = 78;
  public static final int NUMBER              = 79;
  public static final int OPEN                = 80;
  public static final int OPENED              = 81;
  public static final int OPTIONAL            = 82;
  public static final int OUT                 = 83;
  public static final int PARAMETER           = 84;
  public static final int PAUSE               = 85;
  public static final int POINTER             = 86;
  public static final int PRECISION           = 87;
  public static final int PRINT               = 88;
  public static final int PRIVATE             = 89;
  public static final int PROGRAM             = 90;
  public static final int PUBLIC              = 91;
  public static final int PURE                = 92;
  public static final int READ                = 93;
  public static final int REAL                = 94;
  public static final int REC                 = 95;
  public static final int RECL                = 96;
  public static final int RETURN              = 97;
  public static final int REWIND              = 98;
  public static final int SAVE                = 99;
  public static final int SELECT              = 100;
  public static final int SELECTCASE          = 101;
  public static final int SEQUENCE            = 102;
  public static final int SEQUENTIAL          = 103;
  public static final int STATUS              = 104;
  public static final int STOP                = 105;
  public static final int SUBROUTINE          = 106;
  public static final int TARGET              = 107;
  public static final int THEN                = 108;
  public static final int TO                  = 109;
  public static final int TYPE                = 110;
  public static final int UNFORMATTED         = 111;
  public static final int UNIT                = 112;
  public static final int USE                 = 113;
  public static final int WRITE               = 114;
  public static final int WHERE               = 115;
  public static final int WHILE               = 116;

  public static final String[] keywords = {
    "??",              "access",          "allocatable",     "allocate",        
    "assign",          "backspace",       "blank",           "block",           
    "blockdata",       "call",            "case",            "character",       
    "close",           "common",          "complex",         "contains",        
    "continue",        "cycle",           "data",            "deallocate",      
    "dimension",       "direct",          "do",              "double",          
    "doubleprecision", "doublecomplex",   "elemental",       "else",            
    "elseif",          "end",             "endblockdata",    "enddo",           
    "endfile",         "endforall",       "endfunction",     "endif",           
    "endinterface",    "endmodule",       "endprogram",      "endselect",       
    "endsubroutine",   "endtype",         "endwhere",        "entry",           
    "equivalence",     "err",             "exist",           "exit",            
    "external",        "file",            "fmt",             "forall",          
    "form",            "format",          "formatted",       "function",        
    "goto",            "if",              "implicit",        "in",              
    "include",         "inout",           "inquire",         "integer",         
    "intent",          "interface",       "intrinsic",       "iostat",          
    "kind",            "len",             "logical",         "module",          
    "name",            "named",           "namelist",        "nextrec",         
    "none",            "null",            "nullify",         "number",          
    "open",            "opened",          "optional",        "out",             
    "parameter",       "pause",           "pointer",         "precision",       
    "print",           "private",         "program",         "public",          
    "pure",            "read",            "real",            "rec",             
    "recl",            "return",          "rewind",          "save",            
    "select",          "selectcase",      "sequence",        "sequential",      
    "status",          "stop",            "subroutine",      "target",          
    "then",            "to",              "type",            "unformatted",     
    "unit",            "use",             "write",           "where",           
    "while",           
  };

  public static final int[] keywordLengths = {
     0,  6, 11,  8,  6,  9,  5,  5,  9,  4,  4,  9,  5,  6,  7,  8, 
     8,  5,  4, 10,  9,  6,  2,  6, 15, 13,  9,  4,  6,  3, 12,  5, 
     7,  9, 11,  5, 12,  9, 10,  9, 13,  7,  8,  5, 11,  3,  5,  4, 
     8,  4,  3,  6,  4,  6,  9,  8,  4,  2,  8,  2,  7,  5,  7,  7, 
     6,  9,  9,  6,  4,  3,  7,  6,  4,  5,  8,  7,  4,  4,  7,  6, 
     4,  6,  8,  3,  9,  5,  7,  9,  5,  7,  7,  6,  4,  4,  4,  3, 
     4,  6,  6,  4,  6, 10,  8, 10,  6,  4, 10,  6,  4,  2,  4, 11, 
     4,  3,  5,  5,  5, 
  };

  private static final char[] firstChar = {
       4,   88,  164,  324,  504,  960, 1052,    0, 
    1064,    0, 1244, 1256, 1288, 1308, 1416, 1468, 
       0, 1644, 1700, 1852, 1900,    0, 1956,    0, 
       0,    0, 
  };

  private static final char[] bag = {
    /*    0 */ ' ',    0,    0, 0,
    /*    4 */ 'c',   24,    8, 0,
    /*    8 */ 'c',    0,   12, 0,
    /*   12 */ 'e',    0,   16, 0,
    /*   16 */ 's',    0,   20, 0,
    /*   20 */ 's',    0,    0, ACCESS,
    /*   24 */ 'l',   68,   28, 0,
    /*   28 */ 'l',    0,   32, 0,
    /*   32 */ 'o',    0,   36, 0,
    /*   36 */ 'c',    0,   40, 0,
    /*   40 */ 'a',    0,   44, 0,
    /*   44 */ 't',    0,   48, 0,
    /*   48 */ 'a',   64,   52, 0,
    /*   52 */ 'b',    0,   56, 0,
    /*   56 */ 'l',    0,   60, 0,
    /*   60 */ 'e',    0,    0, ALLOCATABLE,
    /*   64 */ 'e',    0,    0, ALLOCATE,
    /*   68 */ 's',    0,   72, 0,
    /*   72 */ 's',    0,   76, 0,
    /*   76 */ 'i',    0,   80, 0,
    /*   80 */ 'g',    0,   84, 0,
    /*   84 */ 'n',    0,    0, ASSIGN,
    /*   88 */ 'a',  120,   92, 0,
    /*   92 */ 'c',    0,   96, 0,
    /*   96 */ 'k',    0,  100, 0,
    /*  100 */ 's',    0,  104, 0,
    /*  104 */ 'p',    0,  108, 0,
    /*  108 */ 'a',    0,  112, 0,
    /*  112 */ 'c',    0,  116, 0,
    /*  116 */ 'e',    0,    0, BACKSPACE,
    /*  120 */ 'l',    0,  124, 0,
    /*  124 */ 'a',  136,  128, 0,
    /*  128 */ 'n',    0,  132, 0,
    /*  132 */ 'k',    0,    0, BLANK,
    /*  136 */ 'o',    0,  140, 0,
    /*  140 */ 'c',    0,  144, 0,
    /*  144 */ 'k',    0,  148, BLOCK,
    /*  148 */ 'd',    0,  152, 0,
    /*  152 */ 'a',    0,  156, 0,
    /*  156 */ 't',    0,  160, 0,
    /*  160 */ 'a',    0,    0, BLOCKDATA,
    /*  164 */ 'a',  184,  168, 0,
    /*  168 */ 'l',  176,  172, 0,
    /*  172 */ 'l',    0,    0, CALL,
    /*  176 */ 's',    0,  180, 0,
    /*  180 */ 'e',    0,    0, CASE,
    /*  184 */ 'h',  216,  188, 0,
    /*  188 */ 'a',    0,  192, 0,
    /*  192 */ 'r',    0,  196, 0,
    /*  196 */ 'a',    0,  200, 0,
    /*  200 */ 'c',    0,  204, 0,
    /*  204 */ 't',    0,  208, 0,
    /*  208 */ 'e',    0,  212, 0,
    /*  212 */ 'r',    0,    0, CHARACTER,
    /*  216 */ 'l',  232,  220, 0,
    /*  220 */ 'o',    0,  224, 0,
    /*  224 */ 's',    0,  228, 0,
    /*  228 */ 'e',    0,    0, CLOSE,
    /*  232 */ 'o',  308,  236, 0,
    /*  236 */ 'm',  268,  240, 0,
    /*  240 */ 'm',  252,  244, 0,
    /*  244 */ 'o',    0,  248, 0,
    /*  248 */ 'n',    0,    0, COMMON,
    /*  252 */ 'p',    0,  256, 0,
    /*  256 */ 'l',    0,  260, 0,
    /*  260 */ 'e',    0,  264, 0,
    /*  264 */ 'x',    0,    0, COMPLEX,
    /*  268 */ 'n',    0,  272, 0,
    /*  272 */ 't',    0,  276, 0,
    /*  276 */ 'a',  292,  280, 0,
    /*  280 */ 'i',    0,  284, 0,
    /*  284 */ 'n',    0,  288, 0,
    /*  288 */ 's',    0,    0, CONTAINS,
    /*  292 */ 'i',    0,  296, 0,
    /*  296 */ 'n',    0,  300, 0,
    /*  300 */ 'u',    0,  304, 0,
    /*  304 */ 'e',    0,    0, CONTINUE,
    /*  308 */ 'y',    0,  312, 0,
    /*  312 */ 'c',    0,  316, 0,
    /*  316 */ 'l',    0,  320, 0,
    /*  320 */ 'e',    0,    0, CYCLE,
    /*  324 */ 'a',  336,  328, 0,
    /*  328 */ 't',    0,  332, 0,
    /*  332 */ 'a',    0,    0, DATA,
    /*  336 */ 'e',  372,  340, 0,
    /*  340 */ 'a',    0,  344, 0,
    /*  344 */ 'l',    0,  348, 0,
    /*  348 */ 'l',    0,  352, 0,
    /*  352 */ 'o',    0,  356, 0,
    /*  356 */ 'c',    0,  360, 0,
    /*  360 */ 'a',    0,  364, 0,
    /*  364 */ 't',    0,  368, 0,
    /*  368 */ 'e',    0,    0, DEALLOCATE,
    /*  372 */ 'i',  420,  376, 0,
    /*  376 */ 'm',  404,  380, 0,
    /*  380 */ 'e',    0,  384, 0,
    /*  384 */ 'n',    0,  388, 0,
    /*  388 */ 's',    0,  392, 0,
    /*  392 */ 'i',    0,  396, 0,
    /*  396 */ 'o',    0,  400, 0,
    /*  400 */ 'n',    0,    0, DIMENSION,
    /*  404 */ 'r',    0,  408, 0,
    /*  408 */ 'e',    0,  412, 0,
    /*  412 */ 'c',    0,  416, 0,
    /*  416 */ 't',    0,    0, DIRECT,
    /*  420 */ 'o',    0,  424, DO,
    /*  424 */ 'u',    0,  428, 0,
    /*  428 */ 'b',    0,  432, 0,
    /*  432 */ 'l',    0,  436, 0,
    /*  436 */ 'e',    0,  440, DOUBLE,
    /*  440 */ 'p',  476,  444, 0,
    /*  444 */ 'r',    0,  448, 0,
    /*  448 */ 'e',    0,  452, 0,
    /*  452 */ 'c',    0,  456, 0,
    /*  456 */ 'i',    0,  460, 0,
    /*  460 */ 's',    0,  464, 0,
    /*  464 */ 'i',    0,  468, 0,
    /*  468 */ 'o',    0,  472, 0,
    /*  472 */ 'n',    0,    0, DOUBLEPRECISION,
    /*  476 */ 'c',    0,  480, 0,
    /*  480 */ 'o',    0,  484, 0,
    /*  484 */ 'm',    0,  488, 0,
    /*  488 */ 'p',    0,  492, 0,
    /*  492 */ 'l',    0,  496, 0,
    /*  496 */ 'e',    0,  500, 0,
    /*  500 */ 'x',    0,    0, DOUBLECOMPLEX,
    /*  504 */ 'l',  552,  508, 0,
    /*  508 */ 'e',  536,  512, 0,
    /*  512 */ 'm',    0,  516, 0,
    /*  516 */ 'e',    0,  520, 0,
    /*  520 */ 'n',    0,  524, 0,
    /*  524 */ 't',    0,  528, 0,
    /*  528 */ 'a',    0,  532, 0,
    /*  532 */ 'l',    0,    0, ELEMENTAL,
    /*  536 */ 's',    0,  540, 0,
    /*  540 */ 'e',    0,  544, ELSE,
    /*  544 */ 'i',    0,  548, 0,
    /*  548 */ 'f',    0,    0, ELSEIF,
    /*  552 */ 'n',  868,  556, 0,
    /*  556 */ 'd',  856,  560, END,
    /*  560 */ 'b',  596,  564, 0,
    /*  564 */ 'l',    0,  568, 0,
    /*  568 */ 'o',    0,  572, 0,
    /*  572 */ 'c',    0,  576, 0,
    /*  576 */ 'k',    0,  580, 0,
    /*  580 */ 'd',    0,  584, 0,
    /*  584 */ 'a',    0,  588, 0,
    /*  588 */ 't',    0,  592, 0,
    /*  592 */ 'a',    0,    0, ENDBLOCKDATA,
    /*  596 */ 'd',  604,  600, 0,
    /*  600 */ 'o',    0,    0, ENDDO,
    /*  604 */ 'f',  668,  608, 0,
    /*  608 */ 'i',  620,  612, 0,
    /*  612 */ 'l',    0,  616, 0,
    /*  616 */ 'e',    0,    0, ENDFILE,
    /*  620 */ 'o',  640,  624, 0,
    /*  624 */ 'r',    0,  628, 0,
    /*  628 */ 'a',    0,  632, 0,
    /*  632 */ 'l',    0,  636, 0,
    /*  636 */ 'l',    0,    0, ENDFORALL,
    /*  640 */ 'u',    0,  644, 0,
    /*  644 */ 'n',    0,  648, 0,
    /*  648 */ 'c',    0,  652, 0,
    /*  652 */ 't',    0,  656, 0,
    /*  656 */ 'i',    0,  660, 0,
    /*  660 */ 'o',    0,  664, 0,
    /*  664 */ 'n',    0,    0, ENDFUNCTION,
    /*  668 */ 'i',  708,  672, 0,
    /*  672 */ 'f',  676,    0, ENDIF,
    /*  676 */ 'n',    0,  680, 0,
    /*  680 */ 't',    0,  684, 0,
    /*  684 */ 'e',    0,  688, 0,
    /*  688 */ 'r',    0,  692, 0,
    /*  692 */ 'f',    0,  696, 0,
    /*  696 */ 'a',    0,  700, 0,
    /*  700 */ 'c',    0,  704, 0,
    /*  704 */ 'e',    0,    0, ENDINTERFACE,
    /*  708 */ 'm',  732,  712, 0,
    /*  712 */ 'o',    0,  716, 0,
    /*  716 */ 'd',    0,  720, 0,
    /*  720 */ 'u',    0,  724, 0,
    /*  724 */ 'l',    0,  728, 0,
    /*  728 */ 'e',    0,    0, ENDMODULE,
    /*  732 */ 'p',  760,  736, 0,
    /*  736 */ 'r',    0,  740, 0,
    /*  740 */ 'o',    0,  744, 0,
    /*  744 */ 'g',    0,  748, 0,
    /*  748 */ 'r',    0,  752, 0,
    /*  752 */ 'a',    0,  756, 0,
    /*  756 */ 'm',    0,    0, ENDPROGRAM,
    /*  760 */ 's',  820,  764, 0,
    /*  764 */ 'e',  784,  768, 0,
    /*  768 */ 'l',    0,  772, 0,
    /*  772 */ 'e',    0,  776, 0,
    /*  776 */ 'c',    0,  780, 0,
    /*  780 */ 't',    0,    0, ENDSELECT,
    /*  784 */ 'u',    0,  788, 0,
    /*  788 */ 'b',    0,  792, 0,
    /*  792 */ 'r',    0,  796, 0,
    /*  796 */ 'o',    0,  800, 0,
    /*  800 */ 'u',    0,  804, 0,
    /*  804 */ 't',    0,  808, 0,
    /*  808 */ 'i',    0,  812, 0,
    /*  812 */ 'n',    0,  816, 0,
    /*  816 */ 'e',    0,    0, ENDSUBROUTINE,
    /*  820 */ 't',  836,  824, 0,
    /*  824 */ 'y',    0,  828, 0,
    /*  828 */ 'p',    0,  832, 0,
    /*  832 */ 'e',    0,    0, ENDTYPE,
    /*  836 */ 'w',    0,  840, 0,
    /*  840 */ 'h',    0,  844, 0,
    /*  844 */ 'e',    0,  848, 0,
    /*  848 */ 'r',    0,  852, 0,
    /*  852 */ 'e',    0,    0, ENDWHERE,
    /*  856 */ 't',    0,  860, 0,
    /*  860 */ 'r',    0,  864, 0,
    /*  864 */ 'y',    0,    0, ENTRY,
    /*  868 */ 'q',  908,  872, 0,
    /*  872 */ 'u',    0,  876, 0,
    /*  876 */ 'i',    0,  880, 0,
    /*  880 */ 'v',    0,  884, 0,
    /*  884 */ 'a',    0,  888, 0,
    /*  888 */ 'l',    0,  892, 0,
    /*  892 */ 'e',    0,  896, 0,
    /*  896 */ 'n',    0,  900, 0,
    /*  900 */ 'c',    0,  904, 0,
    /*  904 */ 'e',    0,    0, EQUIVALENCE,
    /*  908 */ 'r',  916,  912, 0,
    /*  912 */ 'r',    0,    0, ERR,
    /*  916 */ 'x',    0,  920, 0,
    /*  920 */ 'i',  936,  924, 0,
    /*  924 */ 's',  932,  928, 0,
    /*  928 */ 't',    0,    0, EXIST,
    /*  932 */ 't',    0,    0, EXIT,
    /*  936 */ 't',    0,  940, 0,
    /*  940 */ 'e',    0,  944, 0,
    /*  944 */ 'r',    0,  948, 0,
    /*  948 */ 'n',    0,  952, 0,
    /*  952 */ 'a',    0,  956, 0,
    /*  956 */ 'l',    0,    0, EXTERNAL,
    /*  960 */ 'i',  972,  964, 0,
    /*  964 */ 'l',    0,  968, 0,
    /*  968 */ 'e',    0,    0, FILE,
    /*  972 */ 'm',  980,  976, 0,
    /*  976 */ 't',    0,    0, FMT,
    /*  980 */ 'o', 1024,  984, 0,
    /*  984 */ 'r',    0,  988, 0,
    /*  988 */ 'a', 1000,  992, 0,
    /*  992 */ 'l',    0,  996, 0,
    /*  996 */ 'l',    0,    0, FORALL,
    /* 1000 */ 'm',    0, 1004, FORM,
    /* 1004 */ 'a',    0, 1008, 0,
    /* 1008 */ 't',    0, 1012, FORMAT,
    /* 1012 */ 't',    0, 1016, 0,
    /* 1016 */ 'e',    0, 1020, 0,
    /* 1020 */ 'd',    0,    0, FORMATTED,
    /* 1024 */ 'u',    0, 1028, 0,
    /* 1028 */ 'n',    0, 1032, 0,
    /* 1032 */ 'c',    0, 1036, 0,
    /* 1036 */ 't',    0, 1040, 0,
    /* 1040 */ 'i',    0, 1044, 0,
    /* 1044 */ 'o',    0, 1048, 0,
    /* 1048 */ 'n',    0,    0, FUNCTION,
    /* 1052 */ 'o',    0, 1056, 0,
    /* 1056 */ 't',    0, 1060, 0,
    /* 1060 */ 'o',    0,    0, GOTO,
    /* 1064 */ 'f', 1068,    0, IF,
    /* 1068 */ 'm', 1096, 1072, 0,
    /* 1072 */ 'p',    0, 1076, 0,
    /* 1076 */ 'l',    0, 1080, 0,
    /* 1080 */ 'i',    0, 1084, 0,
    /* 1084 */ 'c',    0, 1088, 0,
    /* 1088 */ 'i',    0, 1092, 0,
    /* 1092 */ 't',    0,    0, IMPLICIT,
    /* 1096 */ 'n', 1224, 1100, IN,
    /* 1100 */ 'c', 1120, 1104, 0,
    /* 1104 */ 'l',    0, 1108, 0,
    /* 1108 */ 'u',    0, 1112, 0,
    /* 1112 */ 'd',    0, 1116, 0,
    /* 1116 */ 'e',    0,    0, INCLUDE,
    /* 1120 */ 'o', 1132, 1124, 0,
    /* 1124 */ 'u',    0, 1128, 0,
    /* 1128 */ 't',    0,    0, INOUT,
    /* 1132 */ 'q', 1152, 1136, 0,
    /* 1136 */ 'u',    0, 1140, 0,
    /* 1140 */ 'i',    0, 1144, 0,
    /* 1144 */ 'r',    0, 1148, 0,
    /* 1148 */ 'e',    0,    0, INQUIRE,
    /* 1152 */ 't',    0, 1156, 0,
    /* 1156 */ 'e', 1200, 1160, 0,
    /* 1160 */ 'g', 1172, 1164, 0,
    /* 1164 */ 'e',    0, 1168, 0,
    /* 1168 */ 'r',    0,    0, INTEGER,
    /* 1172 */ 'n', 1180, 1176, 0,
    /* 1176 */ 't',    0,    0, INTENT,
    /* 1180 */ 'r',    0, 1184, 0,
    /* 1184 */ 'f',    0, 1188, 0,
    /* 1188 */ 'a',    0, 1192, 0,
    /* 1192 */ 'c',    0, 1196, 0,
    /* 1196 */ 'e',    0,    0, INTERFACE,
    /* 1200 */ 'r',    0, 1204, 0,
    /* 1204 */ 'i',    0, 1208, 0,
    /* 1208 */ 'n',    0, 1212, 0,
    /* 1212 */ 's',    0, 1216, 0,
    /* 1216 */ 'i',    0, 1220, 0,
    /* 1220 */ 'c',    0,    0, INTRINSIC,
    /* 1224 */ 'o',    0, 1228, 0,
    /* 1228 */ 's',    0, 1232, 0,
    /* 1232 */ 't',    0, 1236, 0,
    /* 1236 */ 'a',    0, 1240, 0,
    /* 1240 */ 't',    0,    0, IOSTAT,
    /* 1244 */ 'i',    0, 1248, 0,
    /* 1248 */ 'n',    0, 1252, 0,
    /* 1252 */ 'd',    0,    0, KIND,
    /* 1256 */ 'e', 1264, 1260, 0,
    /* 1260 */ 'n',    0,    0, LEN,
    /* 1264 */ 'o',    0, 1268, 0,
    /* 1268 */ 'g',    0, 1272, 0,
    /* 1272 */ 'i',    0, 1276, 0,
    /* 1276 */ 'c',    0, 1280, 0,
    /* 1280 */ 'a',    0, 1284, 0,
    /* 1284 */ 'l',    0,    0, LOGICAL,
    /* 1288 */ 'o',    0, 1292, 0,
    /* 1292 */ 'd',    0, 1296, 0,
    /* 1296 */ 'u',    0, 1300, 0,
    /* 1300 */ 'l',    0, 1304, 0,
    /* 1304 */ 'e',    0,    0, MODULE,
    /* 1308 */ 'a', 1340, 1312, 0,
    /* 1312 */ 'm',    0, 1316, 0,
    /* 1316 */ 'e',    0, 1320, NAME,
    /* 1320 */ 'd', 1324,    0, NAMED,
    /* 1324 */ 'l',    0, 1328, 0,
    /* 1328 */ 'i',    0, 1332, 0,
    /* 1332 */ 's',    0, 1336, 0,
    /* 1336 */ 't',    0,    0, NAMELIST,
    /* 1340 */ 'e', 1364, 1344, 0,
    /* 1344 */ 'x',    0, 1348, 0,
    /* 1348 */ 't',    0, 1352, 0,
    /* 1352 */ 'r',    0, 1356, 0,
    /* 1356 */ 'e',    0, 1360, 0,
    /* 1360 */ 'c',    0,    0, NEXTREC,
    /* 1364 */ 'o', 1376, 1368, 0,
    /* 1368 */ 'n',    0, 1372, 0,
    /* 1372 */ 'e',    0,    0, NONE,
    /* 1376 */ 'u',    0, 1380, 0,
    /* 1380 */ 'l', 1400, 1384, 0,
    /* 1384 */ 'l',    0, 1388, NULL,
    /* 1388 */ 'i',    0, 1392, 0,
    /* 1392 */ 'f',    0, 1396, 0,
    /* 1396 */ 'y',    0,    0, NULLIFY,
    /* 1400 */ 'm',    0, 1404, 0,
    /* 1404 */ 'b',    0, 1408, 0,
    /* 1408 */ 'e',    0, 1412, 0,
    /* 1412 */ 'r',    0,    0, NUMBER,
    /* 1416 */ 'p', 1460, 1420, 0,
    /* 1420 */ 'e', 1436, 1424, 0,
    /* 1424 */ 'n',    0, 1428, OPEN,
    /* 1428 */ 'e',    0, 1432, 0,
    /* 1432 */ 'd',    0,    0, OPENED,
    /* 1436 */ 't',    0, 1440, 0,
    /* 1440 */ 'i',    0, 1444, 0,
    /* 1444 */ 'o',    0, 1448, 0,
    /* 1448 */ 'n',    0, 1452, 0,
    /* 1452 */ 'a',    0, 1456, 0,
    /* 1456 */ 'l',    0,    0, OPTIONAL,
    /* 1460 */ 'u',    0, 1464, 0,
    /* 1464 */ 't',    0,    0, OUT,
    /* 1468 */ 'a', 1512, 1472, 0,
    /* 1472 */ 'r', 1500, 1476, 0,
    /* 1476 */ 'a',    0, 1480, 0,
    /* 1480 */ 'm',    0, 1484, 0,
    /* 1484 */ 'e',    0, 1488, 0,
    /* 1488 */ 't',    0, 1492, 0,
    /* 1492 */ 'e',    0, 1496, 0,
    /* 1496 */ 'r',    0,    0, PARAMETER,
    /* 1500 */ 'u',    0, 1504, 0,
    /* 1504 */ 's',    0, 1508, 0,
    /* 1508 */ 'e',    0,    0, PAUSE,
    /* 1512 */ 'o', 1536, 1516, 0,
    /* 1516 */ 'i',    0, 1520, 0,
    /* 1520 */ 'n',    0, 1524, 0,
    /* 1524 */ 't',    0, 1528, 0,
    /* 1528 */ 'e',    0, 1532, 0,
    /* 1532 */ 'r',    0,    0, POINTER,
    /* 1536 */ 'r', 1616, 1540, 0,
    /* 1540 */ 'e', 1568, 1544, 0,
    /* 1544 */ 'c',    0, 1548, 0,
    /* 1548 */ 'i',    0, 1552, 0,
    /* 1552 */ 's',    0, 1556, 0,
    /* 1556 */ 'i',    0, 1560, 0,
    /* 1560 */ 'o',    0, 1564, 0,
    /* 1564 */ 'n',    0,    0, PRECISION,
    /* 1568 */ 'i', 1596, 1572, 0,
    /* 1572 */ 'n', 1580, 1576, 0,
    /* 1576 */ 't',    0,    0, PRINT,
    /* 1580 */ 'v',    0, 1584, 0,
    /* 1584 */ 'a',    0, 1588, 0,
    /* 1588 */ 't',    0, 1592, 0,
    /* 1592 */ 'e',    0,    0, PRIVATE,
    /* 1596 */ 'o',    0, 1600, 0,
    /* 1600 */ 'g',    0, 1604, 0,
    /* 1604 */ 'r',    0, 1608, 0,
    /* 1608 */ 'a',    0, 1612, 0,
    /* 1612 */ 'm',    0,    0, PROGRAM,
    /* 1616 */ 'u',    0, 1620, 0,
    /* 1620 */ 'b', 1636, 1624, 0,
    /* 1624 */ 'l',    0, 1628, 0,
    /* 1628 */ 'i',    0, 1632, 0,
    /* 1632 */ 'c',    0,    0, PUBLIC,
    /* 1636 */ 'r',    0, 1640, 0,
    /* 1640 */ 'e',    0,    0, PURE,
    /* 1644 */ 'e',    0, 1648, 0,
    /* 1648 */ 'a', 1660, 1652, 0,
    /* 1652 */ 'd', 1656,    0, READ,
    /* 1656 */ 'l',    0,    0, REAL,
    /* 1660 */ 'c', 1668, 1664, REC,
    /* 1664 */ 'l',    0,    0, RECL,
    /* 1668 */ 't', 1684, 1672, 0,
    /* 1672 */ 'u',    0, 1676, 0,
    /* 1676 */ 'r',    0, 1680, 0,
    /* 1680 */ 'n',    0,    0, RETURN,
    /* 1684 */ 'w',    0, 1688, 0,
    /* 1688 */ 'i',    0, 1692, 0,
    /* 1692 */ 'n',    0, 1696, 0,
    /* 1696 */ 'd',    0,    0, REWIND,
    /* 1700 */ 'a', 1712, 1704, 0,
    /* 1704 */ 'v',    0, 1708, 0,
    /* 1708 */ 'e',    0,    0, SAVE,
    /* 1712 */ 'e', 1788, 1716, 0,
    /* 1716 */ 'l', 1748, 1720, 0,
    /* 1720 */ 'e',    0, 1724, 0,
    /* 1724 */ 'c',    0, 1728, 0,
    /* 1728 */ 't',    0, 1732, SELECT,
    /* 1732 */ 'c',    0, 1736, 0,
    /* 1736 */ 'a',    0, 1740, 0,
    /* 1740 */ 's',    0, 1744, 0,
    /* 1744 */ 'e',    0,    0, SELECTCASE,
    /* 1748 */ 'q',    0, 1752, 0,
    /* 1752 */ 'u',    0, 1756, 0,
    /* 1756 */ 'e',    0, 1760, 0,
    /* 1760 */ 'n',    0, 1764, 0,
    /* 1764 */ 'c', 1772, 1768, 0,
    /* 1768 */ 'e',    0,    0, SEQUENCE,
    /* 1772 */ 't',    0, 1776, 0,
    /* 1776 */ 'i',    0, 1780, 0,
    /* 1780 */ 'a',    0, 1784, 0,
    /* 1784 */ 'l',    0,    0, SEQUENTIAL,
    /* 1788 */ 't', 1816, 1792, 0,
    /* 1792 */ 'a', 1808, 1796, 0,
    /* 1796 */ 't',    0, 1800, 0,
    /* 1800 */ 'u',    0, 1804, 0,
    /* 1804 */ 's',    0,    0, STATUS,
    /* 1808 */ 'o',    0, 1812, 0,
    /* 1812 */ 'p',    0,    0, STOP,
    /* 1816 */ 'u',    0, 1820, 0,
    /* 1820 */ 'b',    0, 1824, 0,
    /* 1824 */ 'r',    0, 1828, 0,
    /* 1828 */ 'o',    0, 1832, 0,
    /* 1832 */ 'u',    0, 1836, 0,
    /* 1836 */ 't',    0, 1840, 0,
    /* 1840 */ 'i',    0, 1844, 0,
    /* 1844 */ 'n',    0, 1848, 0,
    /* 1848 */ 'e',    0,    0, SUBROUTINE,
    /* 1852 */ 'a', 1872, 1856, 0,
    /* 1856 */ 'r',    0, 1860, 0,
    /* 1860 */ 'g',    0, 1864, 0,
    /* 1864 */ 'e',    0, 1868, 0,
    /* 1868 */ 't',    0,    0, TARGET,
    /* 1872 */ 'h', 1884, 1876, 0,
    /* 1876 */ 'e',    0, 1880, 0,
    /* 1880 */ 'n',    0,    0, THEN,
    /* 1884 */ 'o', 1888,    0, TO,
    /* 1888 */ 'y',    0, 1892, 0,
    /* 1892 */ 'p',    0, 1896, 0,
    /* 1896 */ 'e',    0,    0, TYPE,
    /* 1900 */ 'n', 1948, 1904, 0,
    /* 1904 */ 'f', 1940, 1908, 0,
    /* 1908 */ 'o',    0, 1912, 0,
    /* 1912 */ 'r',    0, 1916, 0,
    /* 1916 */ 'm',    0, 1920, 0,
    /* 1920 */ 'a',    0, 1924, 0,
    /* 1924 */ 't',    0, 1928, 0,
    /* 1928 */ 't',    0, 1932, 0,
    /* 1932 */ 'e',    0, 1936, 0,
    /* 1936 */ 'd',    0,    0, UNFORMATTED,
    /* 1940 */ 'i',    0, 1944, 0,
    /* 1944 */ 't',    0,    0, UNIT,
    /* 1948 */ 's',    0, 1952, 0,
    /* 1952 */ 'e',    0,    0, USE,
    /* 1956 */ 'r', 1972, 1960, 0,
    /* 1960 */ 'i',    0, 1964, 0,
    /* 1964 */ 't',    0, 1968, 0,
    /* 1968 */ 'e',    0,    0, WRITE,
    /* 1972 */ 'h',    0, 1976, 0,
    /* 1976 */ 'e', 1988, 1980, 0,
    /* 1980 */ 'r',    0, 1984, 0,
    /* 1984 */ 'e',    0,    0, WHERE,
    /* 1988 */ 'i',    0, 1992, 0,
    /* 1992 */ 'l',    0, 1996, 0,
    /* 1996 */ 'e',    0,    0, WHILE,
  };

  /**
   * Return the index of the keyword at the specified
   * position.  If no keyword is found, <code>NA</a> is returned.
   * The scan stops at the end of the keyword.  The 
   * <code>f95.setColumn(position)</code> method is called to 
   * update the scan position.
   * @param f95 is the parser
   * @param line contains the characters containing the keyword
   * @param position specifies the start of the possible keyword in the line
   */
  public static int lookup(F95 f95, char[] line, int position)
  {
    char lc = Character.toLowerCase(line[position++]);
    if ((lc < 'a') || (lc > 'z'))
      return 0;

    char ptr = firstChar[lc - 'a'];
    if (ptr == 0)
      return 0;

    lc = line[position];
    if ((lc < 'a') || (lc > 'z'))
      return 0;

    char lptr = 0; // Position of last keyword matched.
    while (true) {
      char kc = bag[ptr];

      if (kc == lc) { // Matched a keyword character.
        if (bag[ptr + 3] != 0)
          lptr = ptr;
        ptr = bag[ptr + 2];
        if (ptr == 0) {
          position++;
          break;
        }

        do {
          position++;
          lc = line[position];
        } while (lc == ' ');

        if ((lc < 'a') || (lc > 'z'))
          break;
        continue;
      }

      ptr = bag[ptr + 1];
      if (ptr == 0) {
        //position++;
        break;
      }
    }

    f95.setColumn(position);
    return bag[lptr + 3];
  }

  /**
   * Return the index of the keyword referenced.
   * If the name is not akeyword, return <code>NA</a>.
   * @param name is the name
   * @param l is the number of characters in name to check
   */
  public static int lookup(String name, int l)
  {
    char lc = Character.toLowerCase(name.charAt(0));
    if ((lc < 'a') || (lc > 'z'))
      return 0;

    char ptr  = firstChar[lc - 'a'];
    int  lptr = 0;
    for (int pos = 1; pos < l; pos++) {
      if (ptr == 0)
        return 0;

      lc = name.charAt(pos);
      if ((lc < 'a') || (lc > 'z'))
        return 0;

      while (lc != bag[ptr]) {
        ptr = bag[ptr + 1];
        if (ptr == 0)
          return 0;
      }

      lptr = ptr;
      ptr = bag[ptr + 2];
    }

    return bag[lptr + 3];
  }

  /**
   * Keyword is allowed in Fortran 95.
   */
  public static final int[] kw_f95 = {0xffffffee, 0xffffffff, 0xffdfffff, 0x1fdfff, };
  /**
   * Keyword is allowed in a MODULE.
   */
  public static final int[] kw_module = {0x314c800, 0x84011000, 0x40100044, 0x24008, };
  /**
   * Keyword can start a statement.
   */
  public static final int[] kw_stmt = {0xfbdfffb8, 0xd7a99fff, 0x653100c4, 0xe560e, };
  /**
   * Keyword is allowed in Fortran 90.
   */
  public static final int[] kw_f90 = {0xfbfffffe, 0xfff7fffd, 0xefffffff, 0x1fdfff, };
  /**
   * Keyword is allowed in an external subprogram.
   */
  public static final int[] kw_extsub = {0x314e800, 0x84211800, 0x40100044, 0x24008, };
  /**
   * Keyword is allowed in a BLOCK DATA.
   */
  public static final int[] kw_block = {0x3146800, 0x84011000, 0x40100044, 0x24008, };
  /**
   * Keyword is allowed in MAIN program.
   */
  public static final int[] kw_main = {0x314e800, 0x84211000, 0x40100044, 0x24008, };
  /**
   * Keyword is allowed in an INTERFACE body.
   */
  public static final int[] kw_interface = {0x3104800, 0x84011000, 0x40100044, 0x24008, };
  /**
   * Keyword is allowed in an internal subprogram.
   */
  public static final int[] kw_intsub = {0x3144800, 0x84211000, 0x40100044, 0x24008, };
  /**
   * Keyword is allowed in if-blocks.
   */
  public static final int[] kw_ifblock = {0x401230, 0x83280000, 0x21210000, 0xc0206, };
  /**
   * Keyword allowed in Fortran 77.
   */
  public static final int[] kw_f77 = {0xfbf57bf2, 0xeff7794d, 0xe5bb9b4c, 0x5b78f, };
  /**
   * Keyword specifies a type.
   */
  public static final int[] kw_type = {0x3804800, 0x80000000, 0x40000040, 0x4000, };
  /**
   * Keyword is allowed in a MODULE subprogram.
   */
  public static final int[] kw_modsub = {0x314c800, 0x84211800, 0x40100044, 0x24008, };
  /**
   * Keyword is an executable statement.
   */
  public static final int[] kw_exe = {0x4b1638, 0x43288801, 0x21210000, 0x40206, };
  /**
   * Keyword may have a construct label.
   */
  public static final int[] kw_construct = {0x400400, 0x2080000, 0x0, 0x80000, };

  /**
   * Return true if the f95 flag is set for this keyword.
   * Keyword is allowed in Fortran 95.
   */
  public static boolean isF95(int keyword)
  {
    int word = keyword / 32;
    int bit  = keyword - (word * 32);
    return ((kw_f95[word] & (1 << bit)) != 0);
  }

  /**
   * Return true if the module flag is set for this keyword.
   * Keyword is allowed in a MODULE.
   */
  public static boolean isModule(int keyword)
  {
    int word = keyword / 32;
    int bit  = keyword - (word * 32);
    return ((kw_module[word] & (1 << bit)) != 0);
  }

  /**
   * Return true if the stmt flag is set for this keyword.
   * Keyword can start a statement.
   */
  public static boolean isStmt(int keyword)
  {
    int word = keyword / 32;
    int bit  = keyword - (word * 32);
    return ((kw_stmt[word] & (1 << bit)) != 0);
  }

  /**
   * Return true if the f90 flag is set for this keyword.
   * Keyword is allowed in Fortran 90.
   */
  public static boolean isF90(int keyword)
  {
    int word = keyword / 32;
    int bit  = keyword - (word * 32);
    return ((kw_f90[word] & (1 << bit)) != 0);
  }

  /**
   * Return true if the extsub flag is set for this keyword.
   * Keyword is allowed in an external subprogram.
   */
  public static boolean isExtsub(int keyword)
  {
    int word = keyword / 32;
    int bit  = keyword - (word * 32);
    return ((kw_extsub[word] & (1 << bit)) != 0);
  }

  /**
   * Return true if the block flag is set for this keyword.
   * Keyword is allowed in a BLOCK DATA.
   */
  public static boolean isBlock(int keyword)
  {
    int word = keyword / 32;
    int bit  = keyword - (word * 32);
    return ((kw_block[word] & (1 << bit)) != 0);
  }

  /**
   * Return true if the main flag is set for this keyword.
   * Keyword is allowed in MAIN program.
   */
  public static boolean isMain(int keyword)
  {
    int word = keyword / 32;
    int bit  = keyword - (word * 32);
    return ((kw_main[word] & (1 << bit)) != 0);
  }

  /**
   * Return true if the interface flag is set for this keyword.
   * Keyword is allowed in an INTERFACE body.
   */
  public static boolean isInterface(int keyword)
  {
    int word = keyword / 32;
    int bit  = keyword - (word * 32);
    return ((kw_interface[word] & (1 << bit)) != 0);
  }

  /**
   * Return true if the intsub flag is set for this keyword.
   * Keyword is allowed in an internal subprogram.
   */
  public static boolean isIntsub(int keyword)
  {
    int word = keyword / 32;
    int bit  = keyword - (word * 32);
    return ((kw_intsub[word] & (1 << bit)) != 0);
  }

  /**
   * Return true if the ifblock flag is set for this keyword.
   * Keyword is allowed in if-blocks.
   */
  public static boolean isIfblock(int keyword)
  {
    int word = keyword / 32;
    int bit  = keyword - (word * 32);
    return ((kw_ifblock[word] & (1 << bit)) != 0);
  }

  /**
   * Return true if the f77 flag is set for this keyword.
   * Keyword allowed in Fortran 77.
   */
  public static boolean isF77(int keyword)
  {
    int word = keyword / 32;
    int bit  = keyword - (word * 32);
    return ((kw_f77[word] & (1 << bit)) != 0);
  }

  /**
   * Return true if the type flag is set for this keyword.
   * Keyword specifies a type.
   */
  public static boolean isType(int keyword)
  {
    int word = keyword / 32;
    int bit  = keyword - (word * 32);
    return ((kw_type[word] & (1 << bit)) != 0);
  }

  /**
   * Return true if the modsub flag is set for this keyword.
   * Keyword is allowed in a MODULE subprogram.
   */
  public static boolean isModsub(int keyword)
  {
    int word = keyword / 32;
    int bit  = keyword - (word * 32);
    return ((kw_modsub[word] & (1 << bit)) != 0);
  }

  /**
   * Return true if the exe flag is set for this keyword.
   * Keyword is an executable statement.
   */
  public static boolean isExe(int keyword)
  {
    int word = keyword / 32;
    int bit  = keyword - (word * 32);
    return ((kw_exe[word] & (1 << bit)) != 0);
  }

  /**
   * Return true if the construct flag is set for this keyword.
   * Keyword may have a construct label.
   */
  public static boolean isConstruct(int keyword)
  {
    int word = keyword / 32;
    int bit  = keyword - (word * 32);
    return ((kw_construct[word] & (1 << bit)) != 0);
  }

  /**
   * Return true if the  flag is set for this keyword.
   * @param flags is one of the <code>kw_</code> flag sets
   */
  public static boolean isSet(int[] flags, int keyword)
  {
    int word = keyword / 32;
    int bit  = keyword - (word * 32);
    return ((flags[word] & (1 << bit)) != 0);
  }
}

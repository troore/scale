package scale.frontend.fortran;

import java.io.*;
import java.util.BitSet;
import java.util.Enumeration;

import scale.common.*;

/** 
 * This class builds the Keyword.java class.
 * <p>
 * $Id: MK.java,v 1.7 2007-01-31 18:37:00 burrill Exp $
 * <p>
 * Copyright 2008 by the
 * <a href="http://ali-www.cs.umass.edu/">Scale Compiler Group</a>,<br>
 * <a href="http://www.cs.umass.edu/">Department of Computer Science</a><br>
 * <a href="http://www.umass.edu/">University of Massachusetts</a>,<br>
 * Amherst MA. 01003, USA<br>
 * All Rights Reserved.<br>
 * <p>
 */
public final class MK
{
  private HashMap<String, int[]>  attrAMap;
  private HashMap<String, String> attrCMap;
  private Vector<String>          keywords;

  private StringBuffer buf;
  private String[]     terms;
  private String       tableName;
  private int          maxkw;
  private char[]       firstChar;
  private char[]       bag;
  private int          bagPtr;
  private short[]      mins;
  private short[]      maxs;

  private MK()
  {
  }

  public static void main(String[] argv)
  {
    MK mk = new MK();
    mk.doit();
  }

  private void doit()
  {
    buf       = new StringBuffer("");
    attrAMap  = new HashMap<String, int[]>(23);
    attrCMap  = new HashMap<String, String>(23);
    terms     = new String[128];
    keywords  = new Vector<String>(200);
    maxkw     = 2;
    firstChar = new char[26];
    bag       = new char[1024];
    bagPtr    = 4;
    mins      = new short[200];
    maxs      = new short[200];

    try {
      FileReader fr = new FileReader("keywords.txt");
      FileWriter wr = new FileWriter("Keywords.java");
      BufferedReader reader = new BufferedReader(fr);

      wr.write("package scale.frontend.fortran;\n");
      wr.write("\n");
      wr.write("/**\n");
      wr.write(" * This class defines the Fortran keywords.\n");
      wr.write(" * <b>Do not edit.</b>\n");
      wr.write(" * <p>\n");
      wr.write(" * Copyright 2008 by the\n");
      wr.write(" * <a href=\"http://ali-www.cs.umass.edu/\">Scale Compiler Group</a>,<br>\n");
      wr.write(" * <a href=\"http://www.cs.umass.edu/\">Department of Computer Science</a><br>\n");
      wr.write(" * Amherst MA. 01003, USA<br>\n");
      wr.write(" * All Rights Reserved.<br>\n");
      wr.write(" * <p>\n");
      wr.write(" * This file is generated by the MK class.\n");
      wr.write(" */\n");
      wr.write("\n");
      wr.write("public final class Keywords\n");
      wr.write("{\n");

      tableName = "keyword";

      writeKeyword("NA", wr, 0);
      keywords.add("??");

      // Read keywords.

      int k = 1;
      while (true) {
        String line = reader.readLine();
        if (line == null)
          break;

        if (line.length() == 0)
          continue;

        if (line.startsWith("***"))
          break;

        int ci  = 0;
        int len = line.length();
        while ((ci < len) && (line.charAt(ci) == ' '))
          ci++;

        if (extractComment(line, ci))
          continue;

        int numTerms = extractTerms(line);
        if (numTerms < 1)
          continue;

        String keyword = terms[0];
        int ll = keyword.length();
        if (ll > maxkw)
          maxkw = ll;

        writeKeyword(keyword, wr, k);
        keywords.add(keyword);
        buildLookup(keyword, k);

        int wrd = k / 32;
        int bit = k - (32 * wrd);
        for (int i = 1; i < numTerms; i++) {
          String term = terms[i];
          int[] bs   = attrAMap.get(term);
          if (bs == null) {
            bs = new int[16];
            attrAMap.put(term, bs);
          }
          bs[wrd] |= 1 << bit;
        }
        k++;
      }

      keywords.add("??");

      wr.write("\n");

      writeKeywords(wr, k);

      wr.write("\n");

      writeLookup(wr);
      wr.write(lookupFtn);

      wr.write("\n");

      writeBitArrays(wr, k);

      writeIsFtns(wr);

      wr.write("}\n");
      wr.close();

      // Read intrinsic function names.

      wr = new FileWriter("Intrinsics.java");

      wr.write("package scale.frontend.fortran;\n");
      wr.write("\n");
      wr.write("/**\n");
      wr.write(" * This class defines the Fortran intrinsic function names.\n");
      wr.write(" * <b>Do not edit.</b>\n");
      wr.write(" * <p>\n");
      wr.write(" * Copyright 2006 by the <a href=\"http://ali-www.cs.umass.edu/\">Scale Compiler Group</a>,<br>\n");
      wr.write(" * <a href=\"http://www.cs.umass.edu/\">Department of Computer Science</a><br>\n");
      wr.write(" * Amherst MA. 01003, USA<br>\n");
      wr.write(" * All Rights Reserved.<br>\n");
      wr.write(" * <p>\n");
      wr.write(" * This file is generated by the MK class.\n");
      wr.write(" */\n");
      wr.write("\n");
      wr.write("public final class Intrinsics\n");
      wr.write("{\n");

      keywords.clear();
      tableName = "intrinsic";
      bagPtr = 4;
      maxkw  = 2;

      writeKeyword("NA", wr, 0);
      keywords.add("??");
      firstChar = new char[26];

      k = 1;
      while (true) {
        String line = reader.readLine();
        if (line == null)
          break;

        if (line.length() == 0)
          continue;

        if (line.startsWith("***"))
          break;

        int ci  = 0;
        int len = line.length();
        while ((ci < len) && (line.charAt(ci) == ' '))
          ci++;

        int ce = ci;
        while ((ce < len) && (line.charAt(ce) != ','))
          ce++;

        String ftn = line.substring(ci, ce).toLowerCase();
        int    ll  = ftn.length();
        if (ll > maxkw)
          maxkw = ll;

        writeKeyword(ftn, wr, k);
        keywords.add(ftn);
        buildLookup(ftn, k);

        ce++;

        ci = ce;
        while ((ce < len) && (line.charAt(ce) != ','))
          ce++;
        int min = Integer.parseInt(line.substring(ci,ce));
        ce++;

        ci = ce;
        while ((ce < len) && (line.charAt(ce) != ','))
          ce++;
        int max = Integer.parseInt(line.substring(ci,ce));

        if (k > mins.length) {
          short[] nmin = new short[k * 2];
          System.arraycopy(mins, 0, nmin, 0, k);
          mins = nmin;
          short[] nmax = new short[k * 2];
          System.arraycopy(mins, 0, nmax, 0, k);
          maxs = nmax;
        }
        mins[k] = (short) min;
        maxs[k] = (short) max;

        k++;
      }

      keywords.add("??");

      wr.write("\n");

      writeKeywords(wr, k);

      wr.write("\n");

      writeMinMax(wr, k);

      wr.write("\n");

      writeLookup(wr);
      wr.write(lookupIntrinsicFtn);

      wr.write("}\n");

      fr.close();
      wr.close();
    } catch(java.io.IOException ex) {
      System.out.println("** " + ex);
      System.exit(1);
    }
  }

  private void writeKeyword(String keyword, Writer wr, int k) throws IOException
  {
    buf.setLength(0);
    buf.append("  public static final int ");
    buf.append(keyword.toUpperCase());
    while (buf.length() < 45)
      buf.append(' ');
    buf.append(" = ");
    buf.append(k);
    buf.append(";\n");
    wr.write(buf.toString());
  }

 private int extractTerms(String line)
  {
    int i = 0;
    int l = line.length();
    int j = 0;

    while (line.charAt(i) == ' ')
      i++;

    while (i < l) {
      int n = line.indexOf(',', i);
      if (n < 0)
        n = l;
      terms[j++] = line.substring(i, n).trim().toLowerCase();
      i = n + 1;
    }

    return j;
  }

  private boolean extractComment(String line, int ci)
  {
    int i = 0;
    int l = line.length();
    int j = 0;

    while (line.charAt(i) == ' ')
      i++;

    if (line.charAt(i) != '/')
      return false;
    i++;
    if (line.charAt(i) != '/')
      return true;
    i++;

    while (line.charAt(i) == ' ')
      i++;

    int ti = line.indexOf(' ', i);
    if (ti < 0)
      return true;

    String term = line.substring(i, ti);
    attrCMap.put(term, line.substring(ti + 1));
    return true;
  }

  private void writeKeywords(Writer wr, int numKeywords) throws IOException
  {
    wr.write("  public static final String[] ");
    wr.write(tableName);
    wr.write("s = {\n    ");

    int j = 0;
    for (int i =  0;  i < numKeywords; i++) {
      String keyword = keywords.get(i);
      wr.write("\"");
      wr.write(keyword);
      wr.write("\", ");
      for (int jj = keyword.length(); jj < maxkw; jj++)
        wr.write(" ");
      j++;
      if (j == 4) {
        wr.write("\n    ");
        j = 0;
      }
    }
    if (j > 0)
      wr.write("\n");
    wr.write("  };\n\n");

    wr.write("  public static final int[] ");
    wr.write(tableName);
    wr.write("Lengths = {\n     0, ");

    int jj = 1;
    for (int i =  1;  i < numKeywords; i++) {
      String keyword = keywords.get(i);
      wr.write(Debug.formatInt(keyword.length(), 2));
      wr.write(", ");
      jj++;
      if (jj == 16) {
        wr.write("\n    ");
        jj = 0;
      }
    }
    if (jj > 0)
      wr.write("\n");
    wr.write("  };\n");
  }

   private void writeBitArrays(Writer wr, int numKeywords) throws IOException
  {
    int                 nw = (numKeywords + 31) / 32;
    Enumeration<String> et = attrAMap.keys();
    while (et.hasMoreElements()) {
      String term = et.nextElement();
      if (term.length() == 0)
        continue;

      int[]  bs      = attrAMap.get(term);
      String comment = attrCMap.get(term);

      wr.write("  /**\n   * ");
      if (comment != null)
        wr.write(comment);
      wr.write("\n   */\n");

      wr.write("  public static final int[] kw_");
      wr.write(term);
      wr.write(" = {");
      for (int i = 0; i < nw; i++) {
        wr.write("0x");
        wr.write(Integer.toHexString(bs[i]));
        wr.write(", ");
      }
      wr.write("};\n");
    }
  }

  private void writeIsFtns(Writer wr) throws IOException
  {
    Enumeration<String> et = attrAMap.keys();
    while (et.hasMoreElements()) {
      String term = et.nextElement();
      if (term.length() == 0)
        continue;
      wr.write("\n  /**\n   * Return true if the ");
      wr.write(term);
      wr.write(" flag is set for this keyword.\n");
      String comment = attrCMap.get(term);
      if (comment != null)
        wr.write("   * " + comment);
      wr.write("\n   */\n");
      wr.write("  public static boolean is");
      wr.write(Character.toUpperCase(term.charAt(0)));
      wr.write(term.substring(1));
      wr.write("(int keyword)\n  {\n");
      wr.write("    int word = keyword / 32;\n    int bit  = keyword - (word * 32);\n");
      wr.write("    return ((kw_");
      wr.write(term);
      wr.write("[word] & (1 << bit)) != 0);\n  }\n");
    }

    wr.write("\n  /**\n   * Return true if the ");
    wr.write(" flag is set for this keyword.\n");
    wr.write("   * @param flags is one of the <code>kw_</code> flag sets\n");
    wr.write("   */\n");
    wr.write("  public static boolean isSet");
    wr.write("(int[] flags, int keyword)\n  {\n");
    wr.write("    int word = keyword / 32;\n    int bit  = keyword - (word * 32);\n");
    wr.write("    return ((flags[word] & (1 << bit)) != 0);\n  }\n");
  }

  private void writeMinMax(Writer wr, int k) throws IOException
  {
    wr.write("  public static final short[] minArgs = {");
    for (int i = 0; i < k; i++) {
      if ((i % 8) == 0) {
        wr.write("\n    /* ");
        wr.write(Debug.formatInt(i, 3));
        wr.write(" */ ");
      }

      wr.write(Integer.toString(mins[i]));
      wr.write(", ");
    }
    wr.write("\n  };\n\n");

    wr.write("  public static final short[] maxArgs = {");
    for (int i = 0; i < k; i++) {
      if ((i % 8) == 0) {
        wr.write("\n    /* ");
        wr.write(Debug.formatInt(i, 3));
        wr.write(" */ ");
      }

      wr.write(Debug.formatInt(maxs[i], 4));
      wr.write(", ");
    }
    wr.write("\n  };\n");
  }

  private void buildLookup(String keyword, int kn)
  {
    int  i    = 1;
    char f    = (char) (keyword.charAt(0) - 'a');
    int  ptr  = firstChar[f];
    int  l    = keyword.length();
    int  last = 0;

    outer:
    while (i < l) {
      char c = keyword.charAt(i++);
      while (ptr != 0) {
        if (bag[ptr] == c) {
          last = ptr + 2;
          ptr = bag[ptr + 2];
          continue outer;
        }
        last = ptr + 1;
        ptr = bag[ptr + 1];
      }

      if (bagPtr >= (bag.length - 4)) {
        char[] nc = new char[bagPtr * 2];
        System.arraycopy(bag, 0, nc, 0, bag.length);
        bag = nc;
      }

      if (last == 0)
        firstChar[f] = (char) bagPtr;
      else 
        bag[last] = (char) bagPtr;

      bag[bagPtr + 0] = c;
      bag[bagPtr + 1] = 0;
      bag[bagPtr + 2] = 0;
      bag[bagPtr + 3] = 0;
      last = bagPtr + 2;
      bagPtr += 4;
      break;
    }

    if (i >= l) {
      bag[bagPtr - 1] = (char) kn;
      return;
    }

    while (i < l) {
      char cc = keyword.charAt(i++);

      if (bagPtr >= (bag.length - 4)) {
        char[] nc = new char[bagPtr * 2];
        System.arraycopy(bag, 0, nc, 0, bag.length);
        bag = nc;
      }

      if (last == 0)
        firstChar[f] = (char) bagPtr;
      else 
        bag[last] = (char) bagPtr;

      bag[bagPtr + 0] = cc;
      bag[bagPtr + 1] = 0;
      bag[bagPtr + 2] = 0;
      bag[bagPtr + 3] = 0;
      last = bagPtr + 2;
      bagPtr += 4;
    }

    bag[bagPtr - 1] = (char) kn;
  }

  private void writeLookup(Writer wr) throws IOException
  {
    wr.write("  private static final char[] firstChar = {\n    ");
    int j = 0;
    for (int i = 0; i < firstChar.length; i++) {
      wr.write(Debug.formatInt(firstChar[i], 4));
      wr.write(", ");
      j++;
      if (j == 8) {
        wr.write("\n    ");
        j = 0;
      }
    }
    wr.write("\n  };\n");
    wr.write("\n  private static final char[] bag = {\n");
    for (int i = 0; i < bagPtr; i += 4) {
      wr.write("    /* ");
      wr.write(Debug.formatInt(i, 4));
      wr.write(" */ '");
      wr.write(bag[i]);
      wr.write("', ");
      wr.write(Debug.formatInt(bag[i + 1], 4));
      wr.write(", ");
      wr.write(Debug.formatInt(bag[i + 2], 4));
      wr.write(", ");
      int ptr = bag[i + 3];
      if (ptr == 0)
        wr.write("0");
      else
        wr.write(keywords.get(ptr).toUpperCase());
      wr.write(",\n");
    }
    wr.write("  };\n\n");
  }

private static final String lookupFtn = 
  "  /**\n" +
  "   * Return the index of the keyword at the specified\n" +
  "   * position.  If no keyword is found, <code>NA</a> is returned.\n" +
  "   * The scan stops at the end of the keyword.  The \n" +
  "   * <code>f95.setColumn(position)</code> method is called to \n" +
  "   * update the scan position.\n" +
  "   * @param f95 is the parser\n" +
  "   * @param line contains the characters containing the keyword\n" +
  "   * @param position specifies the start of the possible keyword in the line\n" +
  "   */\n" +
  "  public static int lookup(F95 f95, char[] line, int position)\n" +
  "  {\n" +
  "    char lc = Character.toLowerCase(line[position++]);\n" +
  "    if ((lc < 'a') || (lc > 'z'))\n" +
  "      return 0;\n" +
  "\n" +
  "    char ptr = firstChar[lc - 'a'];\n" +
  "    if (ptr == 0)\n" +
  "      return 0;\n" +
  "\n" +
  "    lc = line[position];\n" +
  "    if ((lc < 'a') || (lc > 'z'))\n" +
  "      return 0;\n" +
  "\n" +
  "    char lptr = 0; // Position of last keyword matched.\n" +
  "    while (true) {\n" +
  "      char kc = bag[ptr];\n" +
  "\n" +
  "      if (kc == lc) { // Matched a keyword character.\n" +
  "        if (bag[ptr + 3] != 0)\n" +
  "          lptr = ptr;\n" +
  "        ptr = bag[ptr + 2];\n" +
  "        if (ptr == 0) {\n" +
  "          position++;\n" +
  "          break;\n" +
  "        }\n" +
  "\n" +
  "        do {\n" +
  "          position++;\n" +
  "          lc = line[position];\n" +
  "        } while (lc == ' ');\n" +
  "\n" +
  "        if ((lc < 'a') || (lc > 'z'))\n" +
  "          break;\n" +
  "        continue;\n" +
  "      }\n" +
  "\n" +
  "      ptr = bag[ptr + 1];\n" +
  "      if (ptr == 0) {\n" +
  "        //position++;\n" +
  "        break;\n" +
  "      }\n" +
  "    }\n" +
  "\n" +
  "    f95.setColumn(position);\n" +
  "    return bag[lptr + 3];\n" +
  "  }\n" +
  "\n" +
  "  /**\n" +
  "   * Return the index of the keyword referenced.\n" +
  "   * If the name is not akeyword, return <code>NA</a>.\n" +
  "   * @param name is the name\n" +
  "   * @param l is the number of characters in name to check\n" +
  "   */\n" +
  "  public static int lookup(String name, int l)\n" +
  "  {\n" +
  "    char lc = Character.toLowerCase(name.charAt(0));\n" +
  "    if ((lc < 'a') || (lc > 'z'))\n" +
  "      return 0;\n" +
  "\n" +
  "    char ptr  = firstChar[lc - 'a'];\n" +
  "    int  lptr = 0;\n" +
  "    for (int pos = 1; pos < l; pos++) {\n" +
  "      if (ptr == 0)\n" +
  "        return 0;\n" +
  "\n" +
  "      lc = name.charAt(pos);\n" +
  "      if ((lc < 'a') || (lc > 'z'))\n" +
  "        return 0;\n" +
  "\n" +
  "      while (lc != bag[ptr]) {\n" +
  "        ptr = bag[ptr + 1];\n" +
  "        if (ptr == 0)\n" +
  "          return 0;\n" +
  "      }\n" +
  "\n" +
  "      lptr = ptr;\n" +
  "      ptr = bag[ptr + 2];\n" +
  "    }\n" +
  "\n" +
  "    return bag[lptr + 3];\n" +
  "  }\n";

private static final String lookupIntrinsicFtn = 
  "  /**\n" +
  "   * Return the index of the intrinsic referenced.\n" +
  "   * If the name is not an intrinsic name, return <code>NA</a>.\n" +
  "   * @param name is the intrinsic name\n" +
  "   * @param l is the number of characters in name to check\n" +
  "   */\n" +
  "  public static int lookup(String name, int l)\n" +
  "  {\n" +
  "    char lc = Character.toLowerCase(name.charAt(0));\n" +
  "    if ((lc < 'a') || (lc > 'z'))\n" +
  "      return 0;\n" +
  "\n" +
  "    char ptr  = firstChar[lc - 'a'];\n" +
  "    int  lptr = 0;\n" +
  "    for (int pos = 1; pos < l; pos++) {\n" +
  "      if (ptr == 0)\n" +
  "        return 0;\n" +
  "\n" +
  "      lc = name.charAt(pos);\n" +
  "      if ((lc != '_') && ((lc < 'a') || (lc > 'z'))) {\n" +
  "        if ((pos != (l - 1)) && (lc != '0') && (lc != '1'))\n" +
  "          return 0;\n" +
  "      }\n" +
  "\n" +
  "      while (lc != bag[ptr]) {\n" +
  "        ptr = bag[ptr + 1];\n" +
  "        if (ptr == 0)\n" +
  "          return 0;\n" +
  "      }\n" +
  "\n" +
  "      lptr = ptr;\n" +
  "      ptr = bag[ptr + 2];\n" +
  "    }\n" +
  "\n" +
  "    return bag[lptr + 3];\n" +
  "  }\n" +
  "\n";
}
  

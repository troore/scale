package scale.common;

import java.awt.Color;

/**
 * All tools used to display Scale graphs must extend this class.
 * <p>
 * $Id: DisplayGraph.java,v 1.31 2007-08-27 18:26:25 burrill Exp $
 * <p>
 * Copyright 2008 by the
 * <a href="http://ali-www.cs.umass.edu/">Scale Compiler Group</a>,<br>
 * <a href="http://www.cs.umass.edu/">Department of Computer Science</a><br>
 * <a href="http://www.umass.edu/">University of Massachusetts</a>,<br>
 * Amherst MA. 01003, USA<br>
 * All Rights Reserved.<br>
 * <p>

 * The class instances that are displayed must adhere to the
 * DisplayNode interface.
 * <p>
 *  The sequence to using a display graph is
 * <ol>
 * <li>Create a <code>DisplayGraph</code> instance
 * <li>Start a new graph display using {@link #newGraph newGraph()}
 * <li>Add the nodes and edges using {@link #addEdge addEdge()} and
 * {@link #addNode addNode()}.
 * <li>Disply the graphical window using {@link #openWindow openWindow()}
 * <li>Repeat steps 2 through 4 as needed.
 * <li>Before terminating the process call {@link #interact interact()}
 * </ol>
 * <p>
 * Both graph files and GUI instantiations may be generated by classes
 * derived from this base class.
 * <p>
 * <h3>Graphical Displays</h3>
 * <p>
 * It is important that every program, that creates a
 * <code>DisplayGraph</code> instance, call the
 * <code>interact()</code> method and use <code>System.exit()</code>
 * to terminate.  The graphical display class may create additional
 * threads which may not terminate when all of the windows are closed.
 * Thus a simple return from the <code>main()</code> method will not
 * necessarily terminate the process.  The <code>interact()</code>
 * method should be programmed to return only when all the windows are
 * closed.  Then, the sequence
 * <pre>
 *    display.interact();
 *    System.exit(0);
 * </pre>
 * will guarantee proper termination of the complete process.
 * <p>
 * <h3>Graph Files</h3>
 * When the derived class generates a file instead of a display, it
 * must still implement the same methods. However, the
 * <code>interact</code> and <code>closeWindow</code> methods do not
 * need to do anything other than just return.  The file containing
 * the graphing commands should be created and closed by the
 * <code>openWindow</code> method.
 * @see DisplayNode
 */
public abstract class DisplayGraph
{
  /**
   * Grap attribute: display edge labels.
   */
  public static final int DISPLAY_EDGE_LABELS = 1;
  /**
   * Display def-use links.
   */
  public static final int SHOW_DEFUSE = 1;
  /**
   * Display may-use, may-def links.
   */
  public static final int SHOW_MAYUSE = 2;
  /**
   * Display Clef types & declarations.
   */
  public static final int SHOW_CLEF  = 4;
  /**
   * Display Clef types & declarations.
   */
  public static final int SHOW_TYPE  = 8;
  /**
   * Display annotations.
   */
  public static final int SHOW_ANNO   = 16;
  /**
   * Display expressions - both high & low.
   */
  public static final int SHOW_EXPR   = 32;
  /**
   * Display low expressions only.
   */
  public static final int SHOW_LOW_EXPR = 64;
  /**
   * Display high expressions only.
   */
  public static final int SHOW_HIGH_EXPR = 128;
  /**
   * Display data dependence relations.
   */
  public static final int SHOW_DD   = 256;
  /**
   * Display dominance relations.
   */
  public static final int SHOW_DOM   = 512;
  /**
   * Display post dominance relations.
   */
  public static final int SHOW_PDOM   = 1024;
  /**
   * Display control dependence.
   */
  public static final int SHOW_CDG   = 2048;
  /**
   * Mask for SHOW_EXPR, SHOW_LOW_EXPR, SHOW_HIGH_EXPR.
   */
  public static final int SHOW_EXPR_MASK = SHOW_EXPR + SHOW_LOW_EXPR + SHOW_HIGH_EXPR;

  private static DisplayGraph visualizer;

  protected static String outputPath = ".";

  /**
   * Make the specified <code>DisplayGraph</code> available to
   * all parts of the process.  If a visualizer was already
   * set, terminate it.
   */
  public static void setVisualizer(DisplayGraph v)
  {
    if (visualizer != null)
      visualizer.terminate();
    visualizer = v;
  }

  /**
   * Return the current visualizer or <code>null</code> if none.
   */
  public static DisplayGraph getVisualizer()
  {
    return visualizer;
  }

  /**
   * Specify the path to use when creating graphic display files.
   */
  public static void setOutputPath(String path)
  {
    outputPath = path;
  }

  /**
   * Generate the java.awt.Color values for the colors array.
   */
  public static void initColors()
  {
  }

  /**
   * Initialize for a new graph.  Only one graph can be created at a
   * time but multiple graphs can be displayed using just one
   * <code>DisplayGraph</code> instance.
   * @param context is the name associated with the graph
   * @param top if true places the root node at the top of the display
   */
  public abstract void newGraph(String context, boolean top);
  /**
   * Add an edge to the graph from node n1 to node n2.  Attributes of
   * the edge are specified by an integer that contains three fields.
   * <table>
   * <thead>
   * <tr><th>bits</th><th>use</th>
   * </thead>
   * <tbody>
   * <tr><td>5-0</td><td>color</td>
   * <tr><td>6</td><td>type: normal, backedge</td>
   * <tr><td>8-7</td>pattern: solid, dashed, dotted<td></td>
   * </tbody>
   * </table>
   * @param n1 is the first node
   * @param n2 is the second node
   * @param edgeAttributes specifies the color, type, and form of the edge
   * @param edgeInfo is additional information about the edge
   */
  public abstract void addEdge(DisplayNode n1,
                               DisplayNode n2,
                               DColor      color,
                               DEdge       edgeAttributes,
                               Object      edgeInfo);
  /**
   * Add a node to the graph.
   * This method should be used only for nodes that are not connected
   * with an edge.
   * @param n is the node
   */
  public abstract void addNode(DisplayNode n);
   /**
   * Return true if the node has been processed.
   * @param n the node to check
   */
  public abstract boolean visited(DisplayNode n);
  /**
   * Terminates the visualizer process.
   */
  public abstract void terminate();
  /**
   * This opens a new visualization window.  The context string should
   * be unique from that used for any other window.  It should be the
   * same string used when calling {@link #newGraph newGraph()}.

   * <table>
   * <thead>
   * <tr><th>bits</th><th>use</th>
   * </thead>
   * <tbody>
   * <tr><td>0</td><td>display graph edge labels</td>
   * </tbody>
   * </table>
   * @param context is the user defined string to distinguish between
   * different windows
   * @param title is title for the window
   * @param graphAttributes species attributes for the graph
   * @see #newGraph
   */
  public abstract void openWindow(String context,
                                  String title,
                                  int graphAttributes);
  /**
   * This closes an existing visualization window.
   * The context string should be unique from that used for any other window.
   * It should be the same string used when calling newGraph().
   * @param context is the user defined string to distinguish between
   * different windows
   * @see #newGraph
   */
  public abstract void closeWindow(String context);
  /**
   * Return true if the window for the given context still exists.
   */
  public abstract boolean windowExists(String context);
  /**
   * Respond to interative events with this display.
   * The method terminates when the display is terminated.
   */
  public abstract void interact();
  /**
   * Convert a string to a form suitable for display and append it to
   * the StringBuffer.  For example, a double quote (") is converted
   * to "\"" and "\0" is converted to "\\0".
   * @param v the original string
   */
  protected void addDisplayString(String v, StringBuffer buf)
  {
    int n = v.length();

    for (int i = 0; i < n; i++) {
      char ch = v.charAt(i);
      switch (ch) {
      case '\0': buf.append("\\0"); break;
      case '\b': buf.append("\\b"); break;
      case '\t': buf.append("\\t"); break;
      case '\n': buf.append("\\n"); break;
      case '\f': buf.append("\\f"); break;
      case '\r': buf.append("\\r"); break;
      case '"' : buf.append("\\\""); break;
      case '\'': buf.append("\\\'"); break;
      case '\\': buf.append("\\\\"); break;
      default:
        if (((ch >= '\u0001') && (ch <= '\u001F')) ||
            ((ch >  '\u007F') && (ch <= '\u00FF'))) {
          buf.append("\\x");
          buf.append(Long.toHexString(ch));
        } else {
          buf.append(ch);
        }
        break;
      }
    }
  }
}

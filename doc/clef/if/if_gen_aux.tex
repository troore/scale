% -*- Mode: latex; Mode: auto-fill; -*-
\Section{Supporting Components}\label{sec:aux}

This section describes the support that the generation interface
requires from an implementation.  

%==============================================================================
\Subsection{Exception Handling}\label{sec:exceptionHandling}
The generation interface requires that the implementation language
provide an exception handling mechanism.  Individual sections and
routines specify exceptions that are unique to them.  The exceptions
listed below may be returned by any interface routine:
\begin{ErrorList}
\ErrorItem{InternalError} The implementation has detected an error
which should not be able to occur.  This indicates a error in the
implementation itself.
\ErrorItem{InvalidParameters} The top most elements on the stack do
not match the types of elements required by the current procedure.
\ErrorItem{InvalidSemantics} The called routine is not valid within
the context in which it is called.  This error is most likely to be
generated by attempting to push an element on the stack (by calling
the current routine) that is not valid between the current begin/end
pair.
\ErrorItem{OutOfMemory} The implementation is not able to allocate
sufficient memory to complete the routine.
\ErrorItem{Unimplemented} The implementation has chosen to not
implement the called routine.
\end{ErrorList}

Implementations may handle exceptions directly or rely on a default
error handler to process all errors.  The interface provides a routine
for setting the default error handler to a user defined procedure.

\interfaceNS{void}{SetErrorHandler}{void (*er)()}
	%set_error_handler (p: ErrorHandler);
	%(*'p' is called to communicate failures (ie creating a stack or module
	%   that's too big) back to the front-end.  Client or implementation
	%   programming errors (bugs) result in crashes. *)
\begin{functionality}
This routine makes the procedure pointed to by \code{er} the default
error handling procedure.  The procedure \code{er} has no arguments
and returns \key{void}.
\end{functionality}


%==============================================================================
\Subsection{The Implementation Stack}\label{sec:implementationStack}

We have modeled the generation interface after the stack IR used in
the SRC Modula-3 compiler.  The two stacks in the stack IR serve very
different purposes.  The first stack, the implementation stack, allows
different implementations of the stack IR to be connected together.
Beginning at the top implementation in the implementation stack, each
called routine first executes its version of the routine, and then
calls the routine of the same name in the next lower implementation.
This process allows user code to generate several layers of
representation (or perform several functions) with a single call.

In the generation interface, the implementation stack has a limited
set of manipulation routines.  Unlike the other routines in the
interface, the routines which operate on the implementation stack do
not recursively execute on lower representations.  Moreover, user code
can only directly call routines in the top most implementation.
Therefore, the implementation stack must be built bottom-up.  User
code is unlikely to want to change the implementation stack
dynamically, so this capability is not supported.

Note for the implementation stack concept to work, the program must be
able to distinguish between different implementations of the same
routine.  Therfore, the generation interface is implemented as an
abstract base class, \code{GenerationInterface}.  Implementations of
this abstract base class inherit the routine names and provide routine
bodies.  The implementation stack contains instances of these
implementation classes (generally one instance per implementation class).

%--
\interfaceNS{void}{AppendImplementation}{GenerationInterface gi}
\begin{functionality}
This routine appends the implementation \code{gi} at the bottom of the
stack. 
\end{functionality}

%==============================================================================
\Subsection{The Operand Stack}\label{sec:stack}

Section~\ref{sec:implementationStack} discusses one use of a stack
data structure in the generation interface.  This section discusses
the other, more important, use of a stack, the operand stack.  User
code uses the generation interface to generate a high-level
representation of a program by calling interface routines.  Each
routine builds a small piece of the final representation.  Between
calls, the interface must store these pieces somewhere.  The
generation interface's solution is to use the operand stack to pass
information between routines.

The generation interface uses a stack in order to allow a cleaner
division between interface and implementation.  The generation
interface seeks to catch as many errors as possible, but this requires
making some assumptions about the represention being generated (\eg
the representation has an expression node).  These assumed nodes (see
Figures~\ref{fig:if_hier_top}--\ref{fig:if_hier_exp}\footnote{These figures
currently show more detail than the interface needs to know.  This
situation will be fixed when Chapter~\ref{chap:nodes} is written.})
are the elements placed on the operand stack, according to the
interface definition.  However, user code is not permitted to directly
manipulate the stack (only implementation code may do so), so
implementations are free to use whatever nodes they want on the stack,
as long as error checking is performed according to the type
information used in this document.  This frees implementations to use
a different class hierarchy than the one shown (or no hierarchy at
all).  Without a stack (or some similar entity), the interface would
have to return intermediate results to the user code, and so the an
implementation would have to create objects with the type name
specified for each routine.

Therefore, the generation interface uses an abstract stack machine as
its execution model.  Before programmers invoke a routine, they must
ensure that the top of the stack contains the necessary arguments.
A \method{StackPop} routine is provided for removing unwanted elements from
the type of the stack.  Adding elements to the top of the stack
requires calling appropriate interface routines.
%--
\interface{void}{StackPop}{}{Node}{}
\begin{functionality}
This routine removes an element from the top of stack.  Since stack
elements are not accessible to user code, no value is returned and the
stack element is simply no longer on the stack.
\end{functionality}


Each interface routine can accept input both from its argument list
and from the operand stack.  Routines can return results through both
their return value and the operand stack.  Most Interface routines
obtain input from the operand stack and push a single return value on
the stack.  Only a few routines use a \key{return} statement to return
a value.  Argument lists are used to pass leaf information to the
interface.  Throughout this chapter, interface routines are shown in
the following form:
\begin{center}
\interface{return-type}{routine-name}{routine-arguments}
	{arguments-on-stack}{type-of-result-on-stack}
\end{center}
In \node{arguments-on-stack}, the rightmost stack element is the top
of stack.  Though this chapter gives names to the arguments, these
names are only for clarity.  The \manyPops\ symbol, which is usually
found in an end routine, indicates that a routine removes an unknown
number of elements from the stack.  All the elements specified in
\node{arguments-on-stack} are replaced by an element of type
\node{type-of-result-on-stack}.  Currently, no routine pushes more
than one value on the operand stack, but this is permissible.

Not all invocations of a routine will need all the routine's
parameters.  To handle the case when the unnecessary parameters are
expressions, the generation interface defines a special value,
\node{NoExpression}, to represent no value.  

\partitle{Unbounded Input} 
When a construct allows a dynamic number of repeated items (\eg fields
in a record, statements in a block, arguments in a list), the
interface uses a begin/end pair to bracket the repeated elements.  For
example, calls to \method{FormalsBegin} and \method{FormalsEnd}
surround calls to \method{DeclFormal}.  The begin routine does not
have a visible effect on the operand stack, but the end routine
removes all the intervening stack elements, forms a list of these
elements, and pushes a new stack element on the top of the stack which
represents this list.  Unless otherwise stated, user code may build an
empty list by calling the end routine when the stack is identical to
when the begin routine was called.

The generation interface design requires unbounded lists to be
completely pushed on the operand stack before any of the list elements
can be removed.  For some lists (\eg statements in a procedure or
statements in a file), this approach appears wasteful of space.
However, implementations are most likely pushing the actual program
representation on the stack, and this representation must exist
regardless of whether or not it is on the stack.  So, no extra space
may be required.  If space is still a concern, then implementations
may choose to devise a scheme by which appropriate lists are
incrementally compressed on the operand stack, as long as the
semantics of the begin/end pair are preserved.

\partitle{Implementation suggestion} 
Implementations may choose to use an auxillary stack, the list stack,
for begin/end pairs.  Each time a begin occurs, an element is pushed
on the list stack that records the top of stack when the begin routine
was called.  Therefore, when the corresponding end routine is called,
all the elements of the operand stack down to the recorded location
may be removed and formed into a list.

%--
\begin{figure}
\caption{\label{fig:if_hier_top}
  Top level of class hierarchy model used in design of generation interface.}
  \begin{center}
  %\setlength{\epsfxsize}{\textwidth}
  \epsfbox{if/if_hier_node.eps}
  \end{center}
\end{figure}
%--
\begin{figure}
\centering
\caption{\label{fig:if_hier_type}
  Class hierarchy for Types.}
  %\setlength{\epsfxsize}{\textwidth}
  \epsfbox{if/if_hier_type.eps}
\end{figure}
%--
\begin{figure}
\centering
\caption{\label{fig:if_hier_decl}
  Class hierarchy  for Declarations.}
%  \setlength{\epsfxsize}{\textwidth}
  \epsfbox{if/if_hier_decl.eps}
\end{figure}
%--
\begin{figure}
\centering
\caption{\label{fig:if_hier_stmt}
  Class hierarchy for Statements.}
  %\setlength{\epsfxsize}{\textwidth}
  \epsfbox{if/if_hier_stmt.eps}
\end{figure}
%--
\begin{figure}
\centering
\caption{\label{fig:if_hier_exp}
  Class hierarchy for Expressions.}
  \setlength{\epsfxsize}{\textwidth}
  \epsfbox{if/if_hier_exp.eps}
\end{figure}
%--
%\begin{figure}
%\centering
%\caption{\label{fig:if_hier_unit}
%  Class hierarchy for compilation units.}
%  %\setlength{\epsfxsize}{\textwidth}
%  \epsfbox{if/if_hier_unit.eps}
%\end{figure}

\partitle{Implementation Suggestion}
We strongly recommend creating two global variables to aid in
debugging.  These variables are intended to help catch errors with
begin/end pairs.  One variable, \code{listType}, holds an
indication of the type of an arbitrary element popped off the stack by
an end routine.  The other variable, \code{listLength}, holds a count
of how many elements were popped.  These variables' values are valid
until the next end routine.  The initial values of these variables are
\code{NotAType} and zero, respectively.

%==============================================================================
\Subsection{The Symbol and Type Tables}\label{sec:tables}

The generation interface assumes that implementations maintain two
tables related to declarations: a symbol table and a type table.  A
symbol table maintains correspondences between programmer introduced
names (and some language defined names) and their value.  A type table
maintains a representation of each type's structure.  Since the
language parser is responsible for semantic resolution, it already
has all the information contained in these two tables, and indeed most
likely has its own version of these tables.  However, to maintain its
independence from an particular language parser, the generation
interface cannot simply accept the parser's tables directly.  Instead,
these two tables must be built by an implemenation by repeated calls
to type constructor (see Section~\ref{sec:type}) and declaration
routines (see Section~\ref{sec:decl}).  

Since the interface does not know anything about the user code's
tables, any reference to an identifier or type must refer to entries
in the interface implementation's tables.  Hence, user code needs some
way of referring to an entry in an interface implementation's tables.
Appropriate interface routines pass back an entry identifier.
Whenever the implementation makes an entry in one of its tables, it
passes back either a \ret{NameID} which refers to an entry in the
symbol table, or a \ret{TypeID} which refers to an entry in the type
table.  User code must retain a mapping of \ret{NameID}s and
\ret{TypeID}s to entries in its own tables.  Whenever an identifier
is used, the user code can than translate from the entry in its symbol
table to the \ret{NameID} or \ret{TypeID} which identifies the entry
in the implementation's tables.  Implementations should provide
\code{NoName} and \code{NoType} to represent that the corresponding
item does not exist.

%Constructing a symbol table requires some knowledge of the source
%language.  Since the structure of the front end's symbol table is
%unknown to the interface, the generation interface (actually
%implementations of the interface) must build its own symbol table.  As
%long as the correspondences between declarations and uses of
%identifiers are maintained, building a symbol table should be easy
%because the interface does not need to worry about the details of how
%scoping works in the source language.  Unfortunately, passing
%correspondences requires extra work on the part of the interface user
%(\ie calling software).  The user must maintain a correspondence
%between an identifer's \key{Declaration} assigned by the generation
%interface and the user's own symbol table index.  A dictionary data
%structure should be sufficient to mainatin this correspondence.

%The generation interface supports the construction of a simple symbol
%table by implementations of the interface.  Users may open scopes with 
%%the \method{BeginScope} and \method{BeginCompound} methods.  
%a variety of methods.  Compound
%entries in a symbol table (such as a type with subcomponents) are
%built via \method{desc*} methods, and then entered into the symbol
%table with a \method{decl*} method.  The generation interface allows
%users to seed the symbol table with language defined identifiers by
%using the \method{decl\_builtin\_*} methods.  

%------------------------------------------------------------------------------
\subsubsection{The Symbol Table}\label{sec:symbolTable}

This section describes the function of the symbol table in more detail
and lists the routines used to control and access the symbol table.  A
symbol is a name.  Most symbols are created by the programmer (\eg
variable names and procedure names).  Some names are introduced by the
compiler either for compiler generated entities such as compiler
generated labels or as compiler generated names for anonymous entities.
User code also generates a few names with calles to the primitive type
declaration routines\footnote{Primitive types would not have to be
named in order to representat a program.  However, it may be useful in
debugging and quite easy to provide.}.

Many program elements have names: variables, procedures, exceptions
(in some source languages), etc.  The generation interface refers to
any nameable program element as an \emph{entity}.  Every entity in a
program must have a corresponding \emph{entry} in the symbol table,
which maps the name to its value (where a value can have several
parts).  The value of an entity depends on what kind of entity it is.
A value of a type entity is a type; the value of a procedure entity is
its signature and body.  In order for user code to refer to a particular
entity (or equivalently, entry), interface routines return a
\ret{NameID} whenever a new entry is created in the symbol table.
Each implementation is free to define \ret{NameID}'s structure, but it
is conceptually an index into the implementation's symbol table.

After an entity is declared, user code always uses the \ret{NameID} to
refer to the entity.  By not using identifiers, the generation
interface avoids having to understand the source language's scoping
and name conflict resolution rules.  In other words, the symbol table
does not limit the number of times an identifier may appear in a
single scope.  On the other hand, the generation interface cannot
provide name lookup.

%- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\paragraph{Specifying Scopes}
Client code needs to understand scoping, in order to transform code
and generate object code.  Unfortunately, different source languages
may have slightly different scoping rules.  The generation interface
handles this issue by requiring user code to explicitly mark where a
scope begins and ends by using the \method{ScopeBegin} and
\method{ScopeEnd} routines.  These routines do not visibly affect
the contents of the stack.  

Since user code is responsible for semantically resolving the program
before using the generation interface to build an new intermediate
representation, the interface can use a generic block structured
symbol table.  Declarations may appear anywhere within a scope, and
the declared entity is useable anywhere from the point of declaration
to the end of the enclosing scope.  In addition, entities in enclosing
scopes are accessible from an inner scope (note that \emph{visibility}
is a language parser issue).

Note that namespaces are essentially named scopes (see
Section~\ref{sec:namespace}).
%--
\interface{void}{ScopeBegin}{}{}{}
%--
\interface{void}{ScopeEnd}{}{}{}

%- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\paragraph{Entering Entities into the Symbol Table}
The generation interface specifies that all programmer defined
entities (\eg types, labels, procedures) are stored in the symbol
table.  Many entities have names, but some may not.  Entities are
entered into the symbol table either by \emph{declarations} or
\emph{specifications}.  A declaration defines an entities; whereas, a
specification provides partial information about an entity.

%- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\paragraph{Entity References}
In addition to the notion of declarations, the generation interface
maintains the idea of an entity \emph{reference}.  An entity reference
represents an entity independently of its name.  Uses of an entity in
a program are represented by its reference node, rather than its
declaration.  In most cases, a reference is indistinguishable from a
declaration, but not always.  For example consider two variables which
are declared to be aliases of each other.  They have separate
declarations but a single reference.  Because of the similarity
between references and declarations, their class hierarchies are
identical and only the declaration hierarchy is shown (see
Figure~\ref{fig:if_hier_decl}).  \ret{NameID} maps into declarations,
but a routine is provided for mapping from \ret{NameID} to references.

%- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\paragraph{Accessing the Symbol Table}

To avoid having to know the details of how a particular language
manages its symbol table, the generation interface relies on the
requirement that user code semantically resolves identifiers before
using the generation interface.  Hence, user code knows to which
declaration each use of an identifier refers (\ie user code does its
own name lookup).  User code passes this knowledge to the generation
interface by using a \ret{NameID}.  It is a simple type which uniquely
identifies a declaration.  Every declaration routine passes a
\ret{NameID} back.  User code is responsible for maintaining a mapping
between entries in its symbol table and NameIDs.

User code is only permitted to lookup entities which it has already
entered into the symbol table.  Hence, few errors should occur.
Nevertheless, implementations ought to check the validity of
\node{NameID}s. 
% and if possible, verify that the type of the retrieved
% entity matches the expected result type of the routine.

%--
\interface{void}{LookupDecl}{NameID name}{}{Declaration}
%--
\interface{void}{LookupRef}{NameID name}{}{Reference}
%--
\interface{void}{LookupType}{TypeID type}{}{Type}
%--
\interface{void}{LookupTypeDecl}{NameID type}{}{Type}

\subsubsection{Type Table}

The most complicated values in the symbol table are type descriptions.
In fact, type information is maintained in a separate table.  The type
table has its own index, \ret{TypeID}.  If the only use of the type
table were to describe types, the design of the table would be
straightforward.  However, the generation interface must also capture
sufficient semantic information for client code to perform type
equivalence checks.  Determining type equivalence is difficult because
each source language defines its own type equivalence rules.  The
generation interface's approach is to include as much information as
possible in the type table, and then define a general routine which
traverses the type table using a subset of that information to compare
two types.  

\partitle{Adding Information}
Besides the normal information required by type constructors, the
generation interface places two other kinds of information in the type
table.  The first is type names, which are useful for type
equivalence.  To simplify the specification of type names across the
interface, the generation interface takes the name from the type
declaration routine and inserts it into the type table.  The name is
added via a \node{nameBrand} node, which is distinct from a
\node{UserBrand} node.  Note that a \node{NameBrand} node may
include multiple names to handle types with multiple names.  The other
kind of information is language defined type matching rules.  These
rules are captured at the compilation unit level and include such
information as whether or not the source language uses field order to
distinguish record types.

\partitle{Type Equivalence} A general routine is used to perform all
type equivalence checks.  This routine accepts as input an indication
of which of the possible features that distinguish types should be
used for the current comparison.

\partitle{Multiple Type Names}
Source languages generally allow programmers to declare types, which
is naming a type.  Source languages generally allow multiple names to
be associated with the same type.  For example in the following C
code, both \code{gew} and \code{GEW} are names for the same type:
\begin{center}
\begin{minipage}{2.0in}\code{
typedef struct gew \{
\ \ \ int a;
\} GEW;
}\end{minipage}
\end{center}

The generation interface does not guarantee that two equivalent types
will have the same \ret{TypeID}.  Hence, user code cannot use
\ret{TypeID}s to determine type equivalence, but user code should
already have its own way of finding type equivalence.  Implementations
may wish to provide a way for client code to compute type equivalence.

\partitle{Decorated Types}
One reason for not guaranteeing a unique \ret{TypeID} for each type is
because types can be decorated with attributes.
Section~\ref{sec:typeAttributes} discusses the different type
attributes in more detail.  Type attributes are associated with an
individual type node, and any type node may be annotated though the
generation interface does not guarantee that all attributes make
sense.  Attributes do not affect the type of an object, but do
represent information about the object that must be maintained.
Hence, the \ret{TypeID} carries the attribute information as well as
the type.

\partitle{Recursive Types}
One of the hardest aspects of describing types is describing recursive
types.  To handle this situation, the generation interface provides
\method{Incomplete*} routines for types which may refer to instances
of themselves (\ie aggregate types).  Within the definition of the
aggregate type, recursive references may refer to the incomplete type.
After the definition of the aggregate type is complete, user code
should call the \method{CompleteType} routine to establish the
relationship between the incomplete and complete types.

\partitle{Branding}
The generation interface supports a branded type which is used to
distinguish two types which are otherwise type equivalent.  Branding
is a way to introduce a name into the type table, and thereby obtain
name equivalence in a structural equivalence framework.  Branding is
in fact the only way of introducing a name into the type 
table.\footnote{A name is specified when primitive types are declared,
and these are recorded in the type table.  However, these names are
source language defined (\eg int) rather than user or compiler defined,
and they are not used to discriminate types.  Indeed, their only
purpose is debugging support.}

\partitle{Separate Compilation}
Separate compilation complicates type matching because not all type
information is available for each compilation.  For separate
compilation, C/C++ uses name equivalence between files.  Hence, two
types are considered equivalent if they have the same name, regardless
of their actual type declaration.  This unfortuante rule works fine if
the two files never exchange data of this type, otherwise the
programmer has made a non-detectable error.  To support this
mis-feature of C/C++, only the brand (not the type structure) is used
to determine the equivalence of branded types.

%==============================================================================
\Subsection{Identifiers}\label{sec:identifiers}

All practical programming languages use identifiers, user selected
strings, to represent program entities such as variables, types, and
labels.  The generation interface does not use identifiers to
reference these entities, since many programming languages allow the
same identifier to have different meanings in different contexts.
However, the generation interface does permit user code to pass
identifiers through to client code.

The generation interface represents identifiers as strings.  A null
string is interpreted as representing that the programmer did not
specify an identifier.  Among other possible uses, a null string can
be used to indicate anonymous declarations.

%==============================================================================
\Subsection{Stable Storage}\label{sec:storage}

Once the user has finished generating a representation with the
generation interface, he or she is likely to want to save the
representation to some form of stable storage.  The generation
interface provides the following routine for performing this function.
The interpretation of \args{key} is implementation dependent, and the
interface does not provide a mechanism for reading back in the
representation.  This functionality should be provided by other code
which manipulates the generated representation.  

\interface{bool}{WriteRepresentation}{String key}{}{}
\begin{functionality}
This function writes the representation out to an implementation
defined stable storage.  The \args{key} argument supplies an
identifier, most likely a file name, for the written representation.
When multiple implementations are stacked, calling this routine will
write out all the different representations.  Therefore, we suggest
that each implementation modify the key somehow to uniquely identify
its output (\eg a file name extension).  The return value indicates
success or failure, with the value from multiple implementations
combined with a logical or function.
\end{functionality}

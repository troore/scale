2012-5-1
首先定义工程目录为：SCALERELEASE = scale

$(SCALERELEASE)/scale/clef/stmt/:
添加CloneForLoopStmt.java模块。

$(SCALERELEASE)/scale/frontend/c/c99.g:
iterationStatement
<
...|f:KEYWORD_for LParen (...)(expr2=expression)? Semi (expr3=expression)? RParen istmt=statement
{stmt = buildForStmt (expr1, expr2, expr3. istmt, f)}
---
>
...|f:KEYWORD_for LParen (...)(expr2=expression)? Semi (expr3=expression)? RParen ((KEYWORD_clone)=> KEYWORD_clone LParen exprThdNum=expression RParen)? istmt=statement
stmt = ((exprThdNum == null) ? buildForStmt (expr1, expr2, expr3, istmt, f) : buildCloneForStmt (expr1, expr2, expr3, istmt, f, exprThdNum));
然后添加了KEYWORD_clone的定义：KEYWORD_clone = "__CLONE_beta"（目前是测试版）和buildForCloneForStmt的定义。

$(SCALERELEASE)/scale/clef/StmtPredicate.java:
添加对CloneForLoopStmt节点的访问接口：
public void visitCloneForLoopStmt(CloneForLoopStmt n);
由于StmtPredicate是一个顶层interface，其中的method都只声明不实现。

$(SCALERELEASE)/scale/clef/DescendPredicate.java:
添加对CloneForLoopStmt节点的访问接口：
public void visitCloneForLoopStmt(CloneForLoopStmt n)	{ visitTestLoopStmt(n); }

以上两个接口都为以后upcasting的Predicte类型对象访问visitCloneForLoopStmt打基础。

此外，还要分别在$(SCALERELEASE)/scale/clef/Clef2C.java和$(SCALERELEASE)/scale/clef2scribble.java中添加对visitCloneForLoopStmt的实现，因为它们直接或间接的继承了Predicate，目前里面还没有添加任何操作。

2012-5-7
$(SCALERELEASE)/scale/frontend/c/c99.g:
iterationStatement
<
...|f:KEYWORD_for LParen (...)(expr2=expression)? Semi (expr3=expression)? RParen ((KEYWORD_clone)=> KEYWORD_clone LParen exprThdNum=expression RParen)? istmt=statement
{ stmt = ((exprThdNum == null) ? buildForStmt (expr1, expr2, expr3, istmt, f) : buildCloneForStmt (expr1, expr2, expr3, istmt, f, exprThdNum)); };
---
>
...|f:KEYWORD_for LParen (...)(expr2=expression)? Semi (expr3=expression)? RParen ((KEYWORD_clone)=> KEYWORD_clone LParen n0:IntValue RParen {exprClnNum = (int)(n0.getText().charAt(0) - '0');})? istmt=statement
{ stmt = ((exprClnNum > 1) ? buildCloneForStmt (expr1, expr2, expr3, istmt, f, exprClnNum) : buildForStmt (expr1, expr2, expr3, istmt, f)); };
因为要clone的线程数必须在编译时静态得到，而expr的值只有在运行时才能得到。另外，目前不知道antlr是怎样实现IntValue的，在c99.g的词法定义中明明没有定义IntValue的规则。

将原来CloneForLoopStmt中的exprThdNum改为了clnNum，毕竟不是真的多线程，改为clone更准确一些。

在LoopHeaderChord中添加了cloneNumber，标记克隆的份数。

在Clef2Scribble中添加了visitCloneForLoopStmt方法的实现，基本模仿visitForLoopStmt，只是添加了cloneNumber的初始化。

2012-05-16
$(SCALERELEASE)/scale/clef:
定义了两个接口类：CloneSpecialPredicate.java和SpecialForPredicate.java，前者用来在遍历clef
AST的过程中寻找CloneForLoopStmt节点（目前clone只支持for循环，以后如果有对其他循环的扩展，这个Predicate同样可以用来寻找这些循环节点）；SpecialForPredicate用来遍历由CloneSpecialPredicate找到的节点并对该clone的地方（比如局部变量，需要切割的for循环）进行clone。
$(SCALERELEASE)/callGraph:
ClefSearchCloneNodes.java和ClefCloneFor.java分别是对上面两个接口类的实现。ClefSearchCloneNodes的发起可以用一个类似于CallGraph类的computeCallGraph()方法，见Scale.java:line:1905；ClefCloneFor可以在CloneSpecialPredicate的遍历过程中发起。

2012-05-19
$(SCALERELEASE)/scale/clef:
在2012-05-16中提到的两个接口有所更新，CloneSpecialPredicate更名为SearchCloneNodesPredicate表示在遍历AST的过程中寻找需要复制的节点，目前主要考虑的是一些循环节点，如for，while；SpecialForPredicate更名为SpecialClonePredicate，意思是可以进行复制的节点不再局限于for，这将是一个公共接口。
$(SCALERELEASE)/callGraph:
ClefSearchCloneNodes和ClefClone是上面个两个接口的实现。目前在遍历AST的过程中只是对找到的需要复制的for节点做了处理，其他节点以后慢慢扩展；SearchCloneNodesPredicate找到这些需要复制的特殊节点后，ClefSearchCloneNodes首先对循环头做简单处理，转而交给ClefClone进行循环体的处理。此外，在目前需要复制或其他处理的节点（主要是循环体中的Statemnet和Expression）中都添加了处理函数，如copy，可以通过查看SpecialClonePredicate.java获悉那些节点中打了copy补丁，copy通过SpecialClonePredicate中转后控制又回到ClefClone的相应操作中，SpecialClonePredicate起到中转和欺骗编译器的作用，在DraftLog中会详述。
$(SCALERELEASE)/clef/stmt:
继CloneForLoopStmt后，干脆又把它的两个祖先类——TestLoopStmt和LoopStmt也做了修改，新加了CloneTestLoopStmt和CloneLoopStmt，有两个原因：
1.需要复制的循环节点有若干新增的公共元素，如线程数（clnNum），切片数（slcNum）及循环变量（loopVar），需要提到各种循环节点的父类中；
2.控制从ClefSearchCloneNodes转到ClefClone时，形参类型就可以统一为CloneTestLoopStmt或CloneLoopStmt，这样在runtime时就可以利用upcast机制合法将各个具体的循环节点如CloneForLoopStmt，CloneWhileLoopStmt传入而不报错。

TODO:
1.如果一个需要复制的节点其stmt成员不是BlockStmt类型，比如for() xxx;
这就需要新建一个BlockStmt来替换原来的stmt，并把这个stmt插入到BlockStmt的stmts向量中去。其中一个问题是怎样把新建BlockStmt的Scope插入到全局符号表中去。
2.包含数组元素的statement的复制，如a[i]=xxx;。
